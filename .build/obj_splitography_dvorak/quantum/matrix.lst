   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2017 Jun Wako, Jack Humbert
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #if defined(__AVR__)
  20:quantum/matrix.c **** #include <avr/io.h>
  21:quantum/matrix.c **** #endif
  22:quantum/matrix.c **** #include "wait.h"
  23:quantum/matrix.c **** #include "print.h"
  24:quantum/matrix.c **** #include "debug.h"
  25:quantum/matrix.c **** #include "util.h"
  26:quantum/matrix.c **** #include "matrix.h"
  27:quantum/matrix.c **** #include "timer.h"
  28:quantum/matrix.c **** 
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  31:quantum/matrix.c **** 
  32:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  33:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  34:quantum/matrix.c **** #endif
  35:quantum/matrix.c **** 
  36:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  37:quantum/matrix.c ****     static uint16_t debouncing_time;
  38:quantum/matrix.c ****     static bool debouncing = false;
  39:quantum/matrix.c **** #endif
  40:quantum/matrix.c **** 
  41:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  42:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  43:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  44:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  45:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  46:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  47:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  48:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  49:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  50:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  51:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  52:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  53:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  54:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  55:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  56:quantum/matrix.c **** #endif
  57:quantum/matrix.c **** 
  58:quantum/matrix.c **** #ifdef MATRIX_MASKED
  59:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  60:quantum/matrix.c **** #endif
  61:quantum/matrix.c **** 
  62:quantum/matrix.c **** #if (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** #endif
  66:quantum/matrix.c **** 
  67:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  68:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  69:quantum/matrix.c **** 
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	/* epilogue start */
 109:quantum/matrix.c **** }
  23               		.loc 1 109 0
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE10:
  28               		.set	matrix_init_user.localalias.0,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 0
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE8:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 0
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE6:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB27:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE27:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  83               		.loc 1 103 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  89               		.loc 1 104 0
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE9:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 93 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 106               		.loc 1 94 0
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE7:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB12:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117               		.loc 1 116 0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 123               		.loc 1 118 0
 124 0000 84E0      		ldi r24,lo8(4)
 125               	/* epilogue start */
 126 0002 0895      		ret
 127               		.cfi_endproc
 128               	.LFE12:
 130               		.section	.text.matrix_cols,"ax",@progbits
 131               	.global	matrix_cols
 133               	matrix_cols:
 134               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 135               		.loc 1 121 0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 141               		.loc 1 123 0
 142 0000 8CE0      		ldi r24,lo8(12)
 143               	/* epilogue start */
 144 0002 0895      		ret
 145               		.cfi_endproc
 146               	.LFE13:
 148               		.section	.text.matrix_init,"ax",@progbits
 149               	.global	matrix_init
 151               	matrix_init:
 152               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #elif (DIODE_DIRECTION == ROW2COL)
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 153               		.loc 1 149 0
 154               		.cfi_startproc
 155 0000 CF93      		push r28
 156               	.LCFI0:
 157               		.cfi_def_cfa_offset 3
 158               		.cfi_offset 28, -2
 159 0002 DF93      		push r29
 160               	.LCFI1:
 161               		.cfi_def_cfa_offset 4
 162               		.cfi_offset 29, -3
 163               	/* prologue: function */
 164               	/* frame size = 0 */
 165               	/* stack size = 2 */
 166               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 167               		.loc 1 153 0
 168 0004 85B7      		in r24,0x35
 169 0006 8068      		ori r24,lo8(-128)
 170 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 171               		.loc 1 154 0
 172 000a 85B7      		in r24,0x35
 173 000c 8068      		ori r24,lo8(-128)
 174 000e 85BF      		out 0x35,r24
 175               	.LVL4:
 176 0010 A0E0      		ldi r26,lo8(row_pins)
 177 0012 B0E0      		ldi r27,hi8(row_pins)
 178 0014 40E0      		ldi r20,lo8(row_pins+4)
 179 0016 50E0      		ldi r21,hi8(row_pins+4)
 180               	.LBB19:
 181               	.LBB20:
 182               	.LBB21:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 170:quantum/matrix.c ****     }
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****     matrix_init_quantum();
 173:quantum/matrix.c **** }
 174:quantum/matrix.c **** 
 175:quantum/matrix.c **** uint8_t matrix_scan(void)
 176:quantum/matrix.c **** {
 177:quantum/matrix.c **** 
 178:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 179:quantum/matrix.c **** 
 180:quantum/matrix.c ****     // Set row, read cols
 181:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 183:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 184:quantum/matrix.c **** 
 185:quantum/matrix.c ****             if (matrix_changed) {
 186:quantum/matrix.c ****                 debouncing = true;
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 188:quantum/matrix.c ****             }
 189:quantum/matrix.c **** 
 190:quantum/matrix.c **** #       else
 191:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 192:quantum/matrix.c **** #       endif
 193:quantum/matrix.c **** 
 194:quantum/matrix.c ****     }
 195:quantum/matrix.c **** 
 196:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 197:quantum/matrix.c **** 
 198:quantum/matrix.c ****     // Set col, read rows
 199:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 201:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 202:quantum/matrix.c ****             if (matrix_changed) {
 203:quantum/matrix.c ****                 debouncing = true;
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 205:quantum/matrix.c ****             }
 206:quantum/matrix.c **** #       else
 207:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 208:quantum/matrix.c **** #       endif
 209:quantum/matrix.c **** 
 210:quantum/matrix.c ****     }
 211:quantum/matrix.c **** 
 212:quantum/matrix.c **** #endif
 213:quantum/matrix.c **** 
 214:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 215:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 218:quantum/matrix.c ****             }
 219:quantum/matrix.c ****             debouncing = false;
 220:quantum/matrix.c ****         }
 221:quantum/matrix.c **** #   endif
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     matrix_scan_quantum();
 224:quantum/matrix.c ****     return 1;
 225:quantum/matrix.c **** }
 226:quantum/matrix.c **** 
 227:quantum/matrix.c **** bool matrix_is_modified(void)
 228:quantum/matrix.c **** {
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 230:quantum/matrix.c ****     if (debouncing) return false;
 231:quantum/matrix.c **** #endif
 232:quantum/matrix.c ****     return true;
 233:quantum/matrix.c **** }
 234:quantum/matrix.c **** 
 235:quantum/matrix.c **** inline
 236:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 237:quantum/matrix.c **** {
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 239:quantum/matrix.c **** }
 240:quantum/matrix.c **** 
 241:quantum/matrix.c **** inline
 242:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 243:quantum/matrix.c **** {
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 245:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 246:quantum/matrix.c **** #ifdef MATRIX_MASKED
 247:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 248:quantum/matrix.c **** #else
 249:quantum/matrix.c ****     return matrix[row];
 250:quantum/matrix.c **** #endif
 251:quantum/matrix.c **** }
 252:quantum/matrix.c **** 
 253:quantum/matrix.c **** void matrix_print(void)
 254:quantum/matrix.c **** {
 255:quantum/matrix.c ****     print_matrix_header();
 256:quantum/matrix.c **** 
 257:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 258:quantum/matrix.c ****         phex(row); print(": ");
 259:quantum/matrix.c ****         print_matrix_row(row);
 260:quantum/matrix.c ****         print("\n");
 261:quantum/matrix.c ****     }
 262:quantum/matrix.c **** }
 263:quantum/matrix.c **** 
 264:quantum/matrix.c **** uint8_t matrix_key_count(void)
 265:quantum/matrix.c **** {
 266:quantum/matrix.c ****     uint8_t count = 0;
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 269:quantum/matrix.c ****     }
 270:quantum/matrix.c ****     return count;
 271:quantum/matrix.c **** }
 272:quantum/matrix.c **** 
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 276:quantum/matrix.c **** 
 277:quantum/matrix.c **** static void init_cols(void)
 278:quantum/matrix.c **** {
 279:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 283:quantum/matrix.c ****     }
 284:quantum/matrix.c **** }
 285:quantum/matrix.c **** 
 286:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 287:quantum/matrix.c **** {
 288:quantum/matrix.c ****     // Store last value of row prior to reading
 289:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 290:quantum/matrix.c **** 
 291:quantum/matrix.c ****     // Clear data in matrix row
 292:quantum/matrix.c ****     current_matrix[current_row] = 0;
 293:quantum/matrix.c **** 
 294:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 295:quantum/matrix.c ****     select_row(current_row);
 296:quantum/matrix.c ****     wait_us(30);
 297:quantum/matrix.c **** 
 298:quantum/matrix.c ****     // For each col...
 299:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 300:quantum/matrix.c **** 
 301:quantum/matrix.c ****         // Select the col pin to read (active low)
 302:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 304:quantum/matrix.c **** 
 305:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 306:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 307:quantum/matrix.c ****     }
 308:quantum/matrix.c **** 
 309:quantum/matrix.c ****     // Unselect row
 310:quantum/matrix.c ****     unselect_row(current_row);
 311:quantum/matrix.c **** 
 312:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 313:quantum/matrix.c **** }
 314:quantum/matrix.c **** 
 315:quantum/matrix.c **** static void select_row(uint8_t row)
 316:quantum/matrix.c **** {
 317:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 320:quantum/matrix.c **** }
 321:quantum/matrix.c **** 
 322:quantum/matrix.c **** static void unselect_row(uint8_t row)
 323:quantum/matrix.c **** {
 324:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 327:quantum/matrix.c **** }
 328:quantum/matrix.c **** 
 329:quantum/matrix.c **** static void unselect_rows(void)
 330:quantum/matrix.c **** {
 331:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 183               		.loc 1 333 0
 184 0018 C1E0      		ldi r28,lo8(1)
 185 001a D0E0      		ldi r29,0
 186               	.LVL5:
 187               	.L10:
 332:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 188               		.loc 1 332 0
 189 001c 8D91      		ld r24,X+
 190               	.LVL6:
 191               		.loc 1 333 0
 192 001e E82F      		mov r30,r24
 193 0020 E295      		swap r30
 194 0022 EF70      		andi r30,lo8(15)
 195 0024 F0E0      		ldi r31,0
 196 0026 61A1      		ldd r22,Z+33
 197 0028 8F70      		andi r24,lo8(15)
 198               	.LVL7:
 199 002a 9E01      		movw r18,r28
 200 002c 00C0      		rjmp 2f
 201               		1:
 202 002e 220F      		lsl r18
 203               		2:
 204 0030 8A95      		dec r24
 205 0032 02F4      		brpl 1b
 206 0034 922F      		mov r25,r18
 207 0036 9095      		com r25
 208 0038 9623      		and r25,r22
 209 003a 91A3      		std Z+33,r25
 210               	.LVL8:
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 211               		.loc 1 334 0
 212 003c 82A1      		ldd r24,Z+34
 213 003e 822B      		or r24,r18
 214 0040 82A3      		std Z+34,r24
 215               	.LVL9:
 216               	.LBE21:
 331:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 217               		.loc 1 331 0
 218 0042 4A17      		cp r20,r26
 219 0044 5B07      		cpc r21,r27
 220 0046 01F4      		brne .L10
 221 0048 A0E0      		ldi r26,lo8(col_pins)
 222 004a B0E0      		ldi r27,hi8(col_pins)
 223               	.LVL10:
 224 004c 40E0      		ldi r20,lo8(col_pins+12)
 225 004e 50E0      		ldi r21,hi8(col_pins+12)
 226               	.LBE20:
 227               	.LBE19:
 228               	.LBB22:
 229               	.LBB23:
 230               	.LBB24:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 231               		.loc 1 281 0
 232 0050 C1E0      		ldi r28,lo8(1)
 233 0052 D0E0      		ldi r29,0
 234               	.L11:
 235               	.LVL11:
 280:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 236               		.loc 1 280 0
 237 0054 8D91      		ld r24,X+
 238               	.LVL12:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 239               		.loc 1 281 0
 240 0056 E82F      		mov r30,r24
 241 0058 E295      		swap r30
 242 005a EF70      		andi r30,lo8(15)
 243 005c F0E0      		ldi r31,0
 244 005e 61A1      		ldd r22,Z+33
 245 0060 8F70      		andi r24,lo8(15)
 246               	.LVL13:
 247 0062 9E01      		movw r18,r28
 248 0064 00C0      		rjmp 2f
 249               		1:
 250 0066 220F      		lsl r18
 251               		2:
 252 0068 8A95      		dec r24
 253 006a 02F4      		brpl 1b
 254 006c 922F      		mov r25,r18
 255 006e 9095      		com r25
 256 0070 9623      		and r25,r22
 257 0072 91A3      		std Z+33,r25
 258               	.LVL14:
 282:quantum/matrix.c ****     }
 259               		.loc 1 282 0
 260 0074 82A1      		ldd r24,Z+34
 261 0076 822B      		or r24,r18
 262 0078 82A3      		std Z+34,r24
 263               	.LVL15:
 264               	.LBE24:
 279:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 265               		.loc 1 279 0
 266 007a 4A17      		cp r20,r26
 267 007c 5B07      		cpc r21,r27
 268 007e 01F4      		brne .L11
 269               	.LVL16:
 270               	.LBE23:
 271               	.LBE22:
 272               	.LBB25:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 273               		.loc 1 168 0
 274 0080 1092 0000 		sts matrix+1,__zero_reg__
 275 0084 1092 0000 		sts matrix,__zero_reg__
 169:quantum/matrix.c ****     }
 276               		.loc 1 169 0
 277 0088 1092 0000 		sts matrix_debouncing+1,__zero_reg__
 278 008c 1092 0000 		sts matrix_debouncing,__zero_reg__
 279               	.LVL17:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 280               		.loc 1 168 0
 281 0090 1092 0000 		sts matrix+2+1,__zero_reg__
 282 0094 1092 0000 		sts matrix+2,__zero_reg__
 169:quantum/matrix.c ****     }
 283               		.loc 1 169 0
 284 0098 1092 0000 		sts matrix_debouncing+2+1,__zero_reg__
 285 009c 1092 0000 		sts matrix_debouncing+2,__zero_reg__
 286               	.LVL18:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 287               		.loc 1 168 0
 288 00a0 1092 0000 		sts matrix+4+1,__zero_reg__
 289 00a4 1092 0000 		sts matrix+4,__zero_reg__
 169:quantum/matrix.c ****     }
 290               		.loc 1 169 0
 291 00a8 1092 0000 		sts matrix_debouncing+4+1,__zero_reg__
 292 00ac 1092 0000 		sts matrix_debouncing+4,__zero_reg__
 293               	.LVL19:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 294               		.loc 1 168 0
 295 00b0 1092 0000 		sts matrix+6+1,__zero_reg__
 296 00b4 1092 0000 		sts matrix+6,__zero_reg__
 169:quantum/matrix.c ****     }
 297               		.loc 1 169 0
 298 00b8 1092 0000 		sts matrix_debouncing+6+1,__zero_reg__
 299 00bc 1092 0000 		sts matrix_debouncing+6,__zero_reg__
 300               	.LVL20:
 301               	/* epilogue start */
 302               	.LBE25:
 173:quantum/matrix.c **** 
 303               		.loc 1 173 0
 304 00c0 DF91      		pop r29
 305 00c2 CF91      		pop r28
 172:quantum/matrix.c **** }
 306               		.loc 1 172 0
 307 00c4 0C94 0000 		jmp matrix_init_quantum
 308               	.LVL21:
 309               		.cfi_endproc
 310               	.LFE14:
 312               		.section	.text.matrix_scan,"ax",@progbits
 313               	.global	matrix_scan
 315               	matrix_scan:
 316               	.LFB15:
 176:quantum/matrix.c **** 
 317               		.loc 1 176 0
 318               		.cfi_startproc
 319 0000 4F92      		push r4
 320               	.LCFI2:
 321               		.cfi_def_cfa_offset 3
 322               		.cfi_offset 4, -2
 323 0002 5F92      		push r5
 324               	.LCFI3:
 325               		.cfi_def_cfa_offset 4
 326               		.cfi_offset 5, -3
 327 0004 7F92      		push r7
 328               	.LCFI4:
 329               		.cfi_def_cfa_offset 5
 330               		.cfi_offset 7, -4
 331 0006 8F92      		push r8
 332               	.LCFI5:
 333               		.cfi_def_cfa_offset 6
 334               		.cfi_offset 8, -5
 335 0008 9F92      		push r9
 336               	.LCFI6:
 337               		.cfi_def_cfa_offset 7
 338               		.cfi_offset 9, -6
 339 000a AF92      		push r10
 340               	.LCFI7:
 341               		.cfi_def_cfa_offset 8
 342               		.cfi_offset 10, -7
 343 000c BF92      		push r11
 344               	.LCFI8:
 345               		.cfi_def_cfa_offset 9
 346               		.cfi_offset 11, -8
 347 000e CF92      		push r12
 348               	.LCFI9:
 349               		.cfi_def_cfa_offset 10
 350               		.cfi_offset 12, -9
 351 0010 DF92      		push r13
 352               	.LCFI10:
 353               		.cfi_def_cfa_offset 11
 354               		.cfi_offset 13, -10
 355 0012 EF92      		push r14
 356               	.LCFI11:
 357               		.cfi_def_cfa_offset 12
 358               		.cfi_offset 14, -11
 359 0014 FF92      		push r15
 360               	.LCFI12:
 361               		.cfi_def_cfa_offset 13
 362               		.cfi_offset 15, -12
 363 0016 0F93      		push r16
 364               	.LCFI13:
 365               		.cfi_def_cfa_offset 14
 366               		.cfi_offset 16, -13
 367 0018 1F93      		push r17
 368               	.LCFI14:
 369               		.cfi_def_cfa_offset 15
 370               		.cfi_offset 17, -14
 371 001a CF93      		push r28
 372               	.LCFI15:
 373               		.cfi_def_cfa_offset 16
 374               		.cfi_offset 28, -15
 375 001c DF93      		push r29
 376               	.LCFI16:
 377               		.cfi_def_cfa_offset 17
 378               		.cfi_offset 29, -16
 379               	/* prologue: function */
 380               	/* frame size = 0 */
 381               	/* stack size = 15 */
 382               	.L__stack_usage = 15
 383               	.LVL22:
 384 001e C0E0      		ldi r28,lo8(matrix_debouncing)
 385 0020 D0E0      		ldi r29,hi8(matrix_debouncing)
 386 0022 00E0      		ldi r16,lo8(row_pins)
 387 0024 10E0      		ldi r17,hi8(row_pins)
 388 0026 90E0      		ldi r25,lo8(row_pins+4)
 389 0028 A92E      		mov r10,r25
 390 002a 90E0      		ldi r25,hi8(row_pins+4)
 391 002c B92E      		mov r11,r25
 392               	.LBB39:
 393               	.LBB40:
 394               	.LBB41:
 395               	.LBB42:
 396               	.LBB43:
 397               	.LBB44:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 398               		.loc 1 318 0
 399 002e EE24      		clr r14
 400 0030 E394      		inc r14
 401 0032 F12C      		mov r15,__zero_reg__
 402               	.LBE44:
 403               	.LBE43:
 404               	.LBE42:
 405               	.LBE41:
 186:quantum/matrix.c ****                 debouncing_time = timer_read();
 406               		.loc 1 186 0
 407 0034 9924      		clr r9
 408 0036 9394      		inc r9
 409               	.LVL23:
 410               	.L18:
 411               	.LBB57:
 412               	.LBB55:
 289:quantum/matrix.c **** 
 413               		.loc 1 289 0
 414 0038 C880      		ld r12,Y
 415 003a D980      		ldd r13,Y+1
 416               	.LVL24:
 292:quantum/matrix.c **** 
 417               		.loc 1 292 0
 418 003c 1982      		std Y+1,__zero_reg__
 419 003e 1882      		st Y,__zero_reg__
 420               	.LVL25:
 421               	.LBB46:
 422               	.LBB45:
 317:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 423               		.loc 1 317 0
 424 0040 D801      		movw r26,r16
 425 0042 8D91      		ld r24,X+
 426 0044 8D01      		movw r16,r26
 427               	.LVL26:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 428               		.loc 1 318 0
 429 0046 E82F      		mov r30,r24
 430 0048 E295      		swap r30
 431 004a EF70      		andi r30,lo8(15)
 432 004c F0E0      		ldi r31,0
 433 004e 91A1      		ldd r25,Z+33
 434 0050 8F70      		andi r24,lo8(15)
 435               	.LVL27:
 436 0052 9701      		movw r18,r14
 437 0054 00C0      		rjmp 2f
 438               		1:
 439 0056 220F      		lsl r18
 440               		2:
 441 0058 8A95      		dec r24
 442 005a 02F4      		brpl 1b
 443 005c 892F      		mov r24,r25
 444 005e 822B      		or r24,r18
 445 0060 81A3      		std Z+33,r24
 446               	.LVL28:
 319:quantum/matrix.c **** }
 447               		.loc 1 319 0
 448 0062 82A1      		ldd r24,Z+34
 449 0064 822E      		mov r8,r18
 450 0066 8094      		com r8
 451 0068 8821      		and r24,r8
 452 006a 82A3      		std Z+34,r24
 453               	.LVL29:
 454               	.LBE45:
 455               	.LBE46:
 456               	.LBB47:
 457               	.LBB48:
 458               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 459               		.loc 2 276 0
 460 006c B0EA      		ldi r27,lo8(-96)
 461 006e BA95      	1:	dec r27
 462 0070 01F4      		brne 1b
 463               	.LVL30:
 464 0072 80E0      		ldi r24,lo8(col_pins)
 465 0074 482E      		mov r4,r24
 466 0076 80E0      		ldi r24,hi8(col_pins)
 467 0078 582E      		mov r5,r24
 468 007a 90E0      		ldi r25,0
 469 007c 80E0      		ldi r24,0
 470               	.LVL31:
 471               	.L16:
 472               	.LBE48:
 473               	.LBE47:
 474               	.LBB49:
 475               	.LBB50:
 302:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 476               		.loc 1 302 0
 477 007e D201      		movw r26,r4
 478 0080 7D91      		ld r23,X+
 479 0082 2D01      		movw r4,r26
 480               	.LVL32:
 303:quantum/matrix.c **** 
 481               		.loc 1 303 0
 482 0084 472F      		mov r20,r23
 483 0086 4295      		swap r20
 484 0088 4F70      		andi r20,lo8(15)
 485 008a 50E0      		ldi r21,0
 486 008c DA01      		movw r26,r20
 487 008e 9096      		adiw r26,32
 488 0090 7C90      		ld r7,X
 489               	.LVL33:
 306:quantum/matrix.c ****     }
 490               		.loc 1 306 0
 491 0092 4881      		ld r20,Y
 492 0094 5981      		ldd r21,Y+1
 303:quantum/matrix.c **** 
 493               		.loc 1 303 0
 494 0096 7F70      		andi r23,lo8(15)
 495               	.LVL34:
 496 0098 D701      		movw r26,r14
 497 009a 00C0      		rjmp 2f
 498               		1:
 499 009c AA0F      		lsl r26
 500 009e BB1F      		rol r27
 501               		2:
 502 00a0 7A95      		dec r23
 503 00a2 02F4      		brpl 1b
 504 00a4 BD01      		movw r22,r26
 505 00a6 6721      		and r22,r7
 306:quantum/matrix.c ****     }
 506               		.loc 1 306 0
 507 00a8 01F0      		breq .+2
 508 00aa 00C0      		rjmp .L22
 509 00ac B701      		movw r22,r14
 510 00ae 082E      		mov r0,r24
 511 00b0 00C0      		rjmp 2f
 512               		1:
 513 00b2 660F      		lsl r22
 514 00b4 771F      		rol r23
 515               		2:
 516 00b6 0A94      		dec r0
 517 00b8 02F4      		brpl 1b
 518               	.LVL35:
 519               	.L15:
 520 00ba 462B      		or r20,r22
 521 00bc 572B      		or r21,r23
 522 00be 5983      		std Y+1,r21
 523 00c0 4883      		st Y,r20
 524               	.LVL36:
 525 00c2 0196      		adiw r24,1
 526               	.LVL37:
 527               	.LBE50:
 299:quantum/matrix.c **** 
 528               		.loc 1 299 0
 529 00c4 8C30      		cpi r24,12
 530 00c6 9105      		cpc r25,__zero_reg__
 531 00c8 01F4      		brne .L16
 532               	.LVL38:
 533               	.LBE49:
 534               	.LBB52:
 535               	.LBB53:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 536               		.loc 1 325 0
 537 00ca 81A1      		ldd r24,Z+33
 538               	.LVL39:
 539 00cc 8822      		and r8,r24
 540 00ce 81A2      		std Z+33,r8
 541               	.LVL40:
 326:quantum/matrix.c **** }
 542               		.loc 1 326 0
 543 00d0 82A1      		ldd r24,Z+34
 544 00d2 282B      		or r18,r24
 545 00d4 22A3      		std Z+34,r18
 546               	.LVL41:
 547               	.LBE53:
 548               	.LBE52:
 549               	.LBE55:
 550               	.LBE57:
 185:quantum/matrix.c ****                 debouncing = true;
 551               		.loc 1 185 0
 552 00d6 8881      		ld r24,Y
 553 00d8 9981      		ldd r25,Y+1
 554 00da C816      		cp r12,r24
 555 00dc D906      		cpc r13,r25
 556 00de 01F0      		breq .L17
 186:quantum/matrix.c ****                 debouncing_time = timer_read();
 557               		.loc 1 186 0
 558 00e0 9092 0000 		sts debouncing,r9
 187:quantum/matrix.c ****             }
 559               		.loc 1 187 0
 560 00e4 0E94 0000 		call timer_read
 561               	.LVL42:
 562 00e8 9093 0000 		sts debouncing_time+1,r25
 563 00ec 8093 0000 		sts debouncing_time,r24
 564               	.L17:
 565               	.LVL43:
 566 00f0 2296      		adiw r28,2
 567               	.LBE40:
 181:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 568               		.loc 1 181 0 discriminator 2
 569 00f2 A016      		cp r10,r16
 570 00f4 B106      		cpc r11,r17
 571 00f6 01F0      		breq .+2
 572 00f8 00C0      		rjmp .L18
 573               	.LBE39:
 215:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 574               		.loc 1 215 0
 575 00fa 8091 0000 		lds r24,debouncing
 576 00fe 8823      		tst r24
 577 0100 01F0      		breq .L20
 215:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 578               		.loc 1 215 0 is_stmt 0 discriminator 1
 579 0102 8091 0000 		lds r24,debouncing_time
 580 0106 9091 0000 		lds r25,debouncing_time+1
 581 010a 0E94 0000 		call timer_elapsed
 582               	.LVL44:
 583 010e 0697      		sbiw r24,6
 584 0110 00F0      		brlo .L20
 585               	.LVL45:
 586               	.LBB60:
 217:quantum/matrix.c ****             }
 587               		.loc 1 217 0 is_stmt 1
 588 0112 8091 0000 		lds r24,matrix_debouncing
 589 0116 9091 0000 		lds r25,matrix_debouncing+1
 590 011a 9093 0000 		sts matrix+1,r25
 591 011e 8093 0000 		sts matrix,r24
 592               	.LVL46:
 593 0122 8091 0000 		lds r24,matrix_debouncing+2
 594 0126 9091 0000 		lds r25,matrix_debouncing+2+1
 595 012a 9093 0000 		sts matrix+2+1,r25
 596 012e 8093 0000 		sts matrix+2,r24
 597               	.LVL47:
 598 0132 8091 0000 		lds r24,matrix_debouncing+4
 599 0136 9091 0000 		lds r25,matrix_debouncing+4+1
 600 013a 9093 0000 		sts matrix+4+1,r25
 601 013e 8093 0000 		sts matrix+4,r24
 602               	.LVL48:
 603 0142 8091 0000 		lds r24,matrix_debouncing+6
 604 0146 9091 0000 		lds r25,matrix_debouncing+6+1
 605 014a 9093 0000 		sts matrix+6+1,r25
 606 014e 8093 0000 		sts matrix+6,r24
 607               	.LVL49:
 608               	.LBE60:
 219:quantum/matrix.c ****         }
 609               		.loc 1 219 0
 610 0152 1092 0000 		sts debouncing,__zero_reg__
 611               	.LVL50:
 612               	.L20:
 223:quantum/matrix.c ****     return 1;
 613               		.loc 1 223 0
 614 0156 0E94 0000 		call matrix_scan_quantum
 615               	.LVL51:
 225:quantum/matrix.c **** 
 616               		.loc 1 225 0
 617 015a 81E0      		ldi r24,lo8(1)
 618               	/* epilogue start */
 619 015c DF91      		pop r29
 620 015e CF91      		pop r28
 621 0160 1F91      		pop r17
 622 0162 0F91      		pop r16
 623               	.LVL52:
 624 0164 FF90      		pop r15
 625 0166 EF90      		pop r14
 626 0168 DF90      		pop r13
 627 016a CF90      		pop r12
 628 016c BF90      		pop r11
 629 016e AF90      		pop r10
 630 0170 9F90      		pop r9
 631 0172 8F90      		pop r8
 632 0174 7F90      		pop r7
 633 0176 5F90      		pop r5
 634 0178 4F90      		pop r4
 635 017a 0895      		ret
 636               	.LVL53:
 637               	.L22:
 638               	.LBB61:
 639               	.LBB59:
 640               	.LBB58:
 641               	.LBB56:
 642               	.LBB54:
 643               	.LBB51:
 306:quantum/matrix.c ****     }
 644               		.loc 1 306 0
 645 017c 70E0      		ldi r23,0
 646               	.LVL54:
 647 017e 60E0      		ldi r22,0
 648 0180 00C0      		rjmp .L15
 649               	.LBE51:
 650               	.LBE54:
 651               	.LBE56:
 652               	.LBE58:
 653               	.LBE59:
 654               	.LBE61:
 655               		.cfi_endproc
 656               	.LFE15:
 658               		.section	.text.matrix_is_modified,"ax",@progbits
 659               	.global	matrix_is_modified
 661               	matrix_is_modified:
 662               	.LFB16:
 228:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 663               		.loc 1 228 0
 664               		.cfi_startproc
 665               	/* prologue: function */
 666               	/* frame size = 0 */
 667               	/* stack size = 0 */
 668               	.L__stack_usage = 0
 230:quantum/matrix.c **** #endif
 669               		.loc 1 230 0
 670 0000 9091 0000 		lds r25,debouncing
 233:quantum/matrix.c **** 
 671               		.loc 1 233 0
 672 0004 81E0      		ldi r24,lo8(1)
 673 0006 8927      		eor r24,r25
 674               	/* epilogue start */
 675 0008 0895      		ret
 676               		.cfi_endproc
 677               	.LFE16:
 679               		.section	.text.matrix_is_on,"ax",@progbits
 680               	.global	matrix_is_on
 682               	matrix_is_on:
 683               	.LFB17:
 237:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 684               		.loc 1 237 0
 685               		.cfi_startproc
 686               	.LVL55:
 687               	/* prologue: function */
 688               	/* frame size = 0 */
 689               	/* stack size = 0 */
 690               	.L__stack_usage = 0
 238:quantum/matrix.c **** }
 691               		.loc 1 238 0
 692 0000 E82F      		mov r30,r24
 693 0002 F0E0      		ldi r31,0
 694 0004 EE0F      		lsl r30
 695 0006 FF1F      		rol r31
 696               	.LVL56:
 697 0008 E050      		subi r30,lo8(-(matrix))
 698 000a F040      		sbci r31,hi8(-(matrix))
 699 000c 81E0      		ldi r24,lo8(1)
 700 000e 90E0      		ldi r25,0
 701 0010 6230      		cpi r22,lo8(2)
 702 0012 00F4      		brsh .L27
 703 0014 80E0      		ldi r24,0
 704               	.L27:
 705 0016 2081      		ld r18,Z
 706 0018 3181      		ldd r19,Z+1
 707 001a 8223      		and r24,r18
 239:quantum/matrix.c **** 
 708               		.loc 1 239 0
 709 001c 8170      		andi r24,lo8(1)
 710               	/* epilogue start */
 711 001e 0895      		ret
 712               		.cfi_endproc
 713               	.LFE17:
 715               		.section	.text.matrix_get_row,"ax",@progbits
 716               	.global	matrix_get_row
 718               	matrix_get_row:
 719               	.LFB18:
 243:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 720               		.loc 1 243 0
 721               		.cfi_startproc
 722               	.LVL57:
 723               	/* prologue: function */
 724               	/* frame size = 0 */
 725               	/* stack size = 0 */
 726               	.L__stack_usage = 0
 249:quantum/matrix.c **** #endif
 727               		.loc 1 249 0
 728 0000 E82F      		mov r30,r24
 729 0002 F0E0      		ldi r31,0
 730 0004 EE0F      		lsl r30
 731 0006 FF1F      		rol r31
 732               	.LVL58:
 733 0008 E050      		subi r30,lo8(-(matrix))
 734 000a F040      		sbci r31,hi8(-(matrix))
 251:quantum/matrix.c **** 
 735               		.loc 1 251 0
 736 000c 8081      		ld r24,Z
 737 000e 9181      		ldd r25,Z+1
 738               	/* epilogue start */
 739 0010 0895      		ret
 740               		.cfi_endproc
 741               	.LFE18:
 743               		.section	.text.matrix_print,"ax",@progbits
 744               	.global	matrix_print
 746               	matrix_print:
 747               	.LFB19:
 254:quantum/matrix.c ****     print_matrix_header();
 748               		.loc 1 254 0
 749               		.cfi_startproc
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 754               	.LVL59:
 755               	/* epilogue start */
 262:quantum/matrix.c **** 
 756               		.loc 1 262 0
 757 0000 0895      		ret
 758               		.cfi_endproc
 759               	.LFE19:
 761               		.section	.text.matrix_key_count,"ax",@progbits
 762               	.global	matrix_key_count
 764               	matrix_key_count:
 765               	.LFB20:
 265:quantum/matrix.c ****     uint8_t count = 0;
 766               		.loc 1 265 0
 767               		.cfi_startproc
 768 0000 0F93      		push r16
 769               	.LCFI17:
 770               		.cfi_def_cfa_offset 3
 771               		.cfi_offset 16, -2
 772 0002 1F93      		push r17
 773               	.LCFI18:
 774               		.cfi_def_cfa_offset 4
 775               		.cfi_offset 17, -3
 776 0004 CF93      		push r28
 777               	.LCFI19:
 778               		.cfi_def_cfa_offset 5
 779               		.cfi_offset 28, -4
 780               	/* prologue: function */
 781               	/* frame size = 0 */
 782               	/* stack size = 3 */
 783               	.L__stack_usage = 3
 784               	.LVL60:
 785 0006 00E0      		ldi r16,lo8(matrix)
 786 0008 10E0      		ldi r17,hi8(matrix)
 266:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 787               		.loc 1 266 0
 788 000a C0E0      		ldi r28,0
 789               	.LVL61:
 790               	.L31:
 791               	.LBB62:
 268:quantum/matrix.c ****     }
 792               		.loc 1 268 0 discriminator 3
 793 000c F801      		movw r30,r16
 794 000e 8191      		ld r24,Z+
 795 0010 9191      		ld r25,Z+
 796 0012 8F01      		movw r16,r30
 797 0014 0E94 0000 		call bitpop16
 798               	.LVL62:
 799 0018 C80F      		add r28,r24
 800               	.LVL63:
 267:quantum/matrix.c ****         count += matrix_bitpop(i);
 801               		.loc 1 267 0 discriminator 3
 802 001a F0E0      		ldi r31,hi8(matrix+8)
 803 001c 0030      		cpi r16,lo8(matrix+8)
 804 001e 1F07      		cpc r17,r31
 805 0020 01F4      		brne .L31
 806               	.LBE62:
 271:quantum/matrix.c **** 
 807               		.loc 1 271 0
 808 0022 8C2F      		mov r24,r28
 809               	/* epilogue start */
 810 0024 CF91      		pop r28
 811               	.LVL64:
 812 0026 1F91      		pop r17
 813 0028 0F91      		pop r16
 814 002a 0895      		ret
 815               		.cfi_endproc
 816               	.LFE20:
 818               		.section	.bss.matrix_debouncing,"aw",@nobits
 821               	matrix_debouncing:
 822 0000 0000 0000 		.zero	8
 822      0000 0000 
 823               		.section	.bss.matrix,"aw",@nobits
 826               	matrix:
 827 0000 0000 0000 		.zero	8
 827      0000 0000 
 828               		.section	.rodata.col_pins,"a",@progbits
 831               	col_pins:
 832 0000 F0        		.byte	-16
 833 0001 F1        		.byte	-15
 834 0002 F4        		.byte	-12
 835 0003 F5        		.byte	-11
 836 0004 F6        		.byte	-10
 837 0005 F7        		.byte	-9
 838 0006 67        		.byte	103
 839 0007 66        		.byte	102
 840 0008 36        		.byte	54
 841 0009 35        		.byte	53
 842 000a 34        		.byte	52
 843 000b 97        		.byte	-105
 844               		.section	.rodata.row_pins,"a",@progbits
 847               	row_pins:
 848 0000 90        		.byte	-112
 849 0001 91        		.byte	-111
 850 0002 92        		.byte	-110
 851 0003 93        		.byte	-109
 852               		.section	.bss.debouncing,"aw",@nobits
 855               	debouncing:
 856 0000 00        		.zero	1
 857               		.section	.bss.debouncing_time,"aw",@nobits
 860               	debouncing_time:
 861 0000 0000      		.zero	2
 862               		.text
 863               	.Letext0:
 864               		.file 3 "/usr/avr/include/stdint.h"
 865               		.file 4 "./tmk_core/common/debug.h"
 866               		.file 5 "./tmk_core/common/matrix.h"
 867               		.file 6 "./tmk_core/common/timer.h"
 868               		.file 7 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccx4aw0Q.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccx4aw0Q.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccx4aw0Q.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccx4aw0Q.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccx4aw0Q.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccx4aw0Q.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccx4aw0Q.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
     /tmp/ccx4aw0Q.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccx4aw0Q.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccx4aw0Q.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccx4aw0Q.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccx4aw0Q.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccx4aw0Q.s:115    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccx4aw0Q.s:133    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccx4aw0Q.s:151    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccx4aw0Q.s:847    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccx4aw0Q.s:831    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccx4aw0Q.s:826    .bss.matrix:0000000000000000 matrix
     /tmp/ccx4aw0Q.s:821    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccx4aw0Q.s:315    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccx4aw0Q.s:855    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccx4aw0Q.s:860    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccx4aw0Q.s:661    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccx4aw0Q.s:682    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccx4aw0Q.s:718    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccx4aw0Q.s:746    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccx4aw0Q.s:764    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop16
__do_copy_data
__do_clear_bss
