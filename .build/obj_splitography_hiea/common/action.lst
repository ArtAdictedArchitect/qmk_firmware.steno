   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB106:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  48:./tmk_core/common/action.c **** {
  16               		.loc 1 48 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  49:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  50:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  51:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  52:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  53:./tmk_core/common/action.c ****         retro_tapping_counter++;
  54:./tmk_core/common/action.c **** #endif
  55:./tmk_core/common/action.c ****     }
  56:./tmk_core/common/action.c **** 
  57:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  58:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  59:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  60:./tmk_core/common/action.c ****     }
  61:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  62:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  63:./tmk_core/common/action.c ****     }
  64:./tmk_core/common/action.c ****     fauxclicky_check();
  65:./tmk_core/common/action.c **** #endif
  66:./tmk_core/common/action.c **** 
  67:./tmk_core/common/action.c **** #ifdef ONEHAND_ENABLE
  68:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  69:./tmk_core/common/action.c ****         process_hand_swap(&event);
  70:./tmk_core/common/action.c ****     }
  71:./tmk_core/common/action.c **** #endif
  72:./tmk_core/common/action.c **** 
  73:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 73 0
  49 001e 1E82      		std Y+6,__zero_reg__
  50 0020 1D82      		std Y+5,__zero_reg__
  51 0022 85E0      		ldi r24,lo8(5)
  52 0024 FE01      		movw r30,r28
  53 0026 3796      		adiw r30,7
  54 0028 DE01      		movw r26,r28
  55 002a 1196      		adiw r26,1
  56               		0:
  57 002c 0190      		ld r0,Z+
  58 002e 0D92      		st X+,r0
  59 0030 8A95      		dec r24
  60 0032 01F4      		brne 0b
  74:./tmk_core/common/action.c **** 
  75:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  76:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  77:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  78:./tmk_core/common/action.c ****     }
  79:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  80:./tmk_core/common/action.c ****         clear_oneshot_mods();
  81:./tmk_core/common/action.c ****     }
  82:./tmk_core/common/action.c **** #endif
  83:./tmk_core/common/action.c **** 
  84:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  85:./tmk_core/common/action.c ****     action_tapping_process(record);
  61               		.loc 1 85 0
  62 0034 4981      		ldd r20,Y+1
  63               	.LVL1:
  64 0036 5A81      		ldd r21,Y+2
  65               	.LVL2:
  66 0038 6B81      		ldd r22,Y+3
  67 003a 7C81      		ldd r23,Y+4
  68 003c 8D81      		ldd r24,Y+5
  69 003e 9E81      		ldd r25,Y+6
  70               	/* epilogue start */
  86:./tmk_core/common/action.c **** #else
  87:./tmk_core/common/action.c ****     process_record(&record);
  88:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  89:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  90:./tmk_core/common/action.c ****     }
  91:./tmk_core/common/action.c **** #endif
  92:./tmk_core/common/action.c **** }
  71               		.loc 1 92 0
  72 0040 2B96      		adiw r28,11
  73 0042 0FB6      		in __tmp_reg__,__SREG__
  74 0044 F894      		cli
  75 0046 DEBF      		out __SP_H__,r29
  76 0048 0FBE      		out __SREG__,__tmp_reg__
  77 004a CDBF      		out __SP_L__,r28
  78 004c DF91      		pop r29
  79 004e CF91      		pop r28
  85:./tmk_core/common/action.c **** #else
  80               		.loc 1 85 0
  81 0050 0C94 0000 		jmp action_tapping_process
  82               	.LVL3:
  83               		.cfi_endproc
  84               	.LFE106:
  86               		.section	.text.process_record_quantum,"ax",@progbits
  87               		.weak	process_record_quantum
  89               	process_record_quantum:
  90               	.LFB108:
  93:./tmk_core/common/action.c **** 
  94:./tmk_core/common/action.c **** #ifdef ONEHAND_ENABLE
  95:./tmk_core/common/action.c **** bool swap_hands = false;
  96:./tmk_core/common/action.c **** 
  97:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
  98:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  99:./tmk_core/common/action.c **** 
 100:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 101:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 102:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 103:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 104:./tmk_core/common/action.c **** 
 105:./tmk_core/common/action.c ****     if (do_swap) {
 106:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 107:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 108:./tmk_core/common/action.c ****     } else {
 109:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 110:./tmk_core/common/action.c ****     }
 111:./tmk_core/common/action.c **** }
 112:./tmk_core/common/action.c **** #endif
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 115:./tmk_core/common/action.c **** bool disable_action_cache = false;
 116:./tmk_core/common/action.c **** 
 117:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 118:./tmk_core/common/action.c **** {
 119:./tmk_core/common/action.c ****     disable_action_cache = true;
 120:./tmk_core/common/action.c ****     process_record(record);
 121:./tmk_core/common/action.c ****     disable_action_cache = false;
 122:./tmk_core/common/action.c **** }
 123:./tmk_core/common/action.c **** #else
 124:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 125:./tmk_core/common/action.c **** {
 126:./tmk_core/common/action.c ****     process_record(record);
 127:./tmk_core/common/action.c **** }
 128:./tmk_core/common/action.c **** #endif
 129:./tmk_core/common/action.c **** 
 130:./tmk_core/common/action.c **** __attribute__ ((weak))
 131:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  91               		.loc 1 131 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
 132:./tmk_core/common/action.c ****     return true;
 133:./tmk_core/common/action.c **** }
  98               		.loc 1 133 0
  99 0000 81E0      		ldi r24,lo8(1)
 100               	.LVL5:
 101               	/* epilogue start */
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE108:
 106               		.section	.text.register_code,"ax",@progbits
 107               	.global	register_code
 109               	register_code:
 110               	.LFB111:
 134:./tmk_core/common/action.c **** 
 135:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 136:./tmk_core/common/action.c **** {
 137:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 140:./tmk_core/common/action.c ****         return;
 141:./tmk_core/common/action.c **** 
 142:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 143:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 145:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 146:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 147:./tmk_core/common/action.c **** #endif
 148:./tmk_core/common/action.c ****     dprintln();
 149:./tmk_core/common/action.c **** 
 150:./tmk_core/common/action.c ****     process_action(record, action);
 151:./tmk_core/common/action.c **** }
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 154:./tmk_core/common/action.c **** {
 155:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 156:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 157:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 158:./tmk_core/common/action.c **** #endif
 159:./tmk_core/common/action.c **** 
 160:./tmk_core/common/action.c ****     if (event.pressed) {
 161:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 162:./tmk_core/common/action.c ****         clear_weak_mods();
 163:./tmk_core/common/action.c ****     }
 164:./tmk_core/common/action.c **** 
 165:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 166:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 167:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 168:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 169:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 170:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 171:./tmk_core/common/action.c ****     }
 172:./tmk_core/common/action.c **** #endif
 173:./tmk_core/common/action.c **** 
 174:./tmk_core/common/action.c ****     switch (action.kind.id) {
 175:./tmk_core/common/action.c ****         /* Key and Mods */
 176:./tmk_core/common/action.c ****         case ACT_LMODS:
 177:./tmk_core/common/action.c ****         case ACT_RMODS:
 178:./tmk_core/common/action.c ****             {
 179:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 180:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 181:./tmk_core/common/action.c ****                 if (event.pressed) {
 182:./tmk_core/common/action.c ****                     if (mods) {
 183:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 184:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 185:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 186:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 187:./tmk_core/common/action.c ****                             add_mods(mods);
 188:./tmk_core/common/action.c ****                         } else {
 189:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 190:./tmk_core/common/action.c ****                         }
 191:./tmk_core/common/action.c ****                         send_keyboard_report();
 192:./tmk_core/common/action.c ****                     }
 193:./tmk_core/common/action.c ****                     register_code(action.key.code);
 194:./tmk_core/common/action.c ****                 } else {
 195:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 196:./tmk_core/common/action.c ****                     if (mods) {
 197:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 198:./tmk_core/common/action.c ****                             del_mods(mods);
 199:./tmk_core/common/action.c ****                         } else {
 200:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 201:./tmk_core/common/action.c ****                         }
 202:./tmk_core/common/action.c ****                         send_keyboard_report();
 203:./tmk_core/common/action.c ****                     }
 204:./tmk_core/common/action.c ****                 }
 205:./tmk_core/common/action.c ****             }
 206:./tmk_core/common/action.c ****             break;
 207:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 208:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 209:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 210:./tmk_core/common/action.c ****             {
 211:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 212:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 213:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 214:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 215:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 216:./tmk_core/common/action.c ****                         // Oneshot modifier
 217:./tmk_core/common/action.c ****                         if (event.pressed) {
 218:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 219:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 220:./tmk_core/common/action.c ****                                 register_mods(mods);
 221:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 222:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 223:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods);
 224:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 225:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 226:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 227:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 228:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 229:./tmk_core/common/action.c ****                                 register_mods(mods);
 230:./tmk_core/common/action.c ****                     #endif
 231:./tmk_core/common/action.c ****                             } else {
 232:./tmk_core/common/action.c ****                                 register_mods(mods);
 233:./tmk_core/common/action.c ****                             }
 234:./tmk_core/common/action.c ****                         } else {
 235:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 236:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 237:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 238:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 239:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 240:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 241:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 242:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 243:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 244:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 245:./tmk_core/common/action.c ****                                 }
 246:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 247:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 248:./tmk_core/common/action.c ****                     #endif
 249:./tmk_core/common/action.c ****                             } else {
 250:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 251:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 252:./tmk_core/common/action.c ****                             }
 253:./tmk_core/common/action.c ****                         }
 254:./tmk_core/common/action.c ****                         break;
 255:./tmk_core/common/action.c ****     #endif
 256:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 257:./tmk_core/common/action.c ****                         if (event.pressed) {
 258:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 259:./tmk_core/common/action.c ****                                 register_mods(mods);
 260:./tmk_core/common/action.c ****                             }
 261:./tmk_core/common/action.c ****                         } else {
 262:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 263:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 264:./tmk_core/common/action.c ****                             }
 265:./tmk_core/common/action.c ****                         }
 266:./tmk_core/common/action.c ****                         break;
 267:./tmk_core/common/action.c ****                     default:
 268:./tmk_core/common/action.c ****                         if (event.pressed) {
 269:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 270:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 271:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 272:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 273:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 274:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 275:./tmk_core/common/action.c ****                                     register_mods(mods);
 276:./tmk_core/common/action.c ****                                 } else
 277:./tmk_core/common/action.c **** #endif
 278:./tmk_core/common/action.c ****                                 {
 279:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 280:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 281:./tmk_core/common/action.c ****                                 }
 282:./tmk_core/common/action.c ****                             } else {
 283:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 284:./tmk_core/common/action.c ****                                 register_mods(mods);
 285:./tmk_core/common/action.c ****                             }
 286:./tmk_core/common/action.c ****                         } else {
 287:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 288:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 289:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****                 }
 297:./tmk_core/common/action.c ****             }
 298:./tmk_core/common/action.c ****             break;
 299:./tmk_core/common/action.c **** #endif
 300:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 301:./tmk_core/common/action.c ****         /* other HID usage */
 302:./tmk_core/common/action.c ****         case ACT_USAGE:
 303:./tmk_core/common/action.c ****             switch (action.usage.page) {
 304:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 305:./tmk_core/common/action.c ****                     if (event.pressed) {
 306:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 307:./tmk_core/common/action.c ****                     } else {
 308:./tmk_core/common/action.c ****                         host_system_send(0);
 309:./tmk_core/common/action.c ****                     }
 310:./tmk_core/common/action.c ****                     break;
 311:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 312:./tmk_core/common/action.c ****                     if (event.pressed) {
 313:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 314:./tmk_core/common/action.c ****                     } else {
 315:./tmk_core/common/action.c ****                         host_consumer_send(0);
 316:./tmk_core/common/action.c ****                     }
 317:./tmk_core/common/action.c ****                     break;
 318:./tmk_core/common/action.c ****             }
 319:./tmk_core/common/action.c ****             break;
 320:./tmk_core/common/action.c **** #endif
 321:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 322:./tmk_core/common/action.c ****         /* Mouse key */
 323:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 324:./tmk_core/common/action.c ****             if (event.pressed) {
 325:./tmk_core/common/action.c ****                 switch (action.key.code) {
 326:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 327:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 328:./tmk_core/common/action.c ****                         break;
 329:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 330:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 331:./tmk_core/common/action.c ****                         break;
 332:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 333:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 334:./tmk_core/common/action.c ****                         break;
 335:./tmk_core/common/action.c ****                     default:
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 339:./tmk_core/common/action.c ****                 mousekey_send();
 340:./tmk_core/common/action.c ****             } else {
 341:./tmk_core/common/action.c ****                 switch (action.key.code) {
 342:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 343:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 344:./tmk_core/common/action.c ****                         break;
 345:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 346:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 347:./tmk_core/common/action.c ****                         break;
 348:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 349:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 350:./tmk_core/common/action.c ****                         break;
 351:./tmk_core/common/action.c ****                     default:
 352:./tmk_core/common/action.c ****                         break;
 353:./tmk_core/common/action.c ****                 }
 354:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 355:./tmk_core/common/action.c ****                 mousekey_send();
 356:./tmk_core/common/action.c ****             }
 357:./tmk_core/common/action.c ****             break;
 358:./tmk_core/common/action.c **** #endif
 359:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 360:./tmk_core/common/action.c ****         case ACT_LAYER:
 361:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 362:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 363:./tmk_core/common/action.c ****                 if (!event.pressed) {
 364:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 365:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 366:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 367:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 368:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 369:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 370:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 371:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 372:./tmk_core/common/action.c ****                     }
 373:./tmk_core/common/action.c ****                 }
 374:./tmk_core/common/action.c ****             } else {
 375:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 376:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 377:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 378:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 379:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 380:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 381:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 382:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 383:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 384:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 385:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 386:./tmk_core/common/action.c ****                     }
 387:./tmk_core/common/action.c ****                 }
 388:./tmk_core/common/action.c ****             }
 389:./tmk_core/common/action.c ****             break;
 390:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 391:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 392:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 393:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 394:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 395:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 396:./tmk_core/common/action.c ****                     if (event.pressed) {
 397:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 398:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 399:./tmk_core/common/action.c ****                     } else {
 400:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 401:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 402:./tmk_core/common/action.c ****                     }
 403:./tmk_core/common/action.c ****                     break;
 404:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 405:./tmk_core/common/action.c ****                     /* tap toggle */
 406:./tmk_core/common/action.c ****                     if (event.pressed) {
 407:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 408:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 409:./tmk_core/common/action.c ****                         }
 410:./tmk_core/common/action.c ****                     } else {
 411:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 412:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 413:./tmk_core/common/action.c ****                         }
 414:./tmk_core/common/action.c ****                     }
 415:./tmk_core/common/action.c ****                     break;
 416:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 417:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 418:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 419:./tmk_core/common/action.c ****                     break;
 420:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 421:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 422:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 423:./tmk_core/common/action.c ****                     break;
 424:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 425:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 426:./tmk_core/common/action.c ****                                     layer_clear();
 427:./tmk_core/common/action.c ****                     break;
 428:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 429:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 430:./tmk_core/common/action.c ****                     // Oneshot modifier
 431:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 432:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 433:./tmk_core/common/action.c ****                     if (event.pressed) {
 434:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 435:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 436:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 437:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 438:./tmk_core/common/action.c ****                             break;
 439:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 440:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 441:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 442:./tmk_core/common/action.c ****                         }
 443:./tmk_core/common/action.c ****                     } else {
 444:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 445:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 446:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 447:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 448:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 449:./tmk_core/common/action.c ****                         } else {
 450:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 451:./tmk_core/common/action.c ****                         }
 452:./tmk_core/common/action.c ****                     }
 453:./tmk_core/common/action.c ****                 #else
 454:./tmk_core/common/action.c ****                     if (event.pressed) {
 455:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 456:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 457:./tmk_core/common/action.c ****                     } else {
 458:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 459:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 460:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 461:./tmk_core/common/action.c ****                         }
 462:./tmk_core/common/action.c ****                     }
 463:./tmk_core/common/action.c ****                 #endif
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****             #endif
 466:./tmk_core/common/action.c ****                 default:
 467:./tmk_core/common/action.c ****                     /* tap key */
 468:./tmk_core/common/action.c ****                     if (event.pressed) {
 469:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 470:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 471:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 472:./tmk_core/common/action.c ****                         } else {
 473:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 474:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 475:./tmk_core/common/action.c ****                         }
 476:./tmk_core/common/action.c ****                     } else {
 477:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 478:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 479:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 480:./tmk_core/common/action.c ****                                 wait_ms(80);
 481:./tmk_core/common/action.c ****                             }
 482:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 483:./tmk_core/common/action.c ****                         } else {
 484:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 485:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 486:./tmk_core/common/action.c ****                         }
 487:./tmk_core/common/action.c ****                     }
 488:./tmk_core/common/action.c ****                     break;
 489:./tmk_core/common/action.c ****             }
 490:./tmk_core/common/action.c ****             break;
 491:./tmk_core/common/action.c ****     #endif
 492:./tmk_core/common/action.c **** #endif
 493:./tmk_core/common/action.c ****         /* Extentions */
 494:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 495:./tmk_core/common/action.c ****         case ACT_MACRO:
 496:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 497:./tmk_core/common/action.c ****             break;
 498:./tmk_core/common/action.c **** #endif
 499:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 500:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 501:./tmk_core/common/action.c ****             if (!event.pressed) {
 502:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 503:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 504:./tmk_core/common/action.c ****                         backlight_increase();
 505:./tmk_core/common/action.c ****                         break;
 506:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 507:./tmk_core/common/action.c ****                         backlight_decrease();
 508:./tmk_core/common/action.c ****                         break;
 509:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 510:./tmk_core/common/action.c ****                         backlight_toggle();
 511:./tmk_core/common/action.c ****                         break;
 512:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 513:./tmk_core/common/action.c ****                         backlight_step();
 514:./tmk_core/common/action.c ****                         break;
 515:./tmk_core/common/action.c ****                     case BACKLIGHT_LEVEL:
 516:./tmk_core/common/action.c ****                         backlight_level(action.backlight.level);
 517:./tmk_core/common/action.c ****                         break;
 518:./tmk_core/common/action.c ****                 }
 519:./tmk_core/common/action.c ****             }
 520:./tmk_core/common/action.c ****             break;
 521:./tmk_core/common/action.c **** #endif
 522:./tmk_core/common/action.c ****         case ACT_COMMAND:
 523:./tmk_core/common/action.c ****             break;
 524:./tmk_core/common/action.c **** #ifdef ONEHAND_ENABLE
 525:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 526:./tmk_core/common/action.c ****             switch (action.swap.code) {
 527:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 528:./tmk_core/common/action.c ****                     if (event.pressed) {
 529:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 530:./tmk_core/common/action.c ****                     }
 531:./tmk_core/common/action.c ****                     break;
 532:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 533:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 534:./tmk_core/common/action.c ****                     break;
 535:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 536:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 537:./tmk_core/common/action.c ****                     break;
 538:./tmk_core/common/action.c ****                 case OP_SH_ON:
 539:./tmk_core/common/action.c ****                     if (!event.pressed) {
 540:./tmk_core/common/action.c ****                         swap_hands = true;
 541:./tmk_core/common/action.c ****                     }
 542:./tmk_core/common/action.c ****                     break;
 543:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 544:./tmk_core/common/action.c ****                     if (!event.pressed) {
 545:./tmk_core/common/action.c ****                         swap_hands = false;
 546:./tmk_core/common/action.c ****                     }
 547:./tmk_core/common/action.c ****                     break;
 548:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 549:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 550:./tmk_core/common/action.c ****                     /* tap toggle */
 551:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 552:./tmk_core/common/action.c ****                         if (!event.pressed) {
 553:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 554:./tmk_core/common/action.c ****                         }
 555:./tmk_core/common/action.c ****                     } else {
 556:./tmk_core/common/action.c ****                         swap_hands = event.pressed;
 557:./tmk_core/common/action.c ****                     }
 558:./tmk_core/common/action.c ****                     break;
 559:./tmk_core/common/action.c ****                 default:
 560:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 561:./tmk_core/common/action.c ****                         if (event.pressed) {
 562:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 563:./tmk_core/common/action.c ****                         } else {
 564:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 565:./tmk_core/common/action.c ****                         }
 566:./tmk_core/common/action.c ****                     } else {
 567:./tmk_core/common/action.c ****                         swap_hands = event.pressed;
 568:./tmk_core/common/action.c ****                     }
 569:./tmk_core/common/action.c ****     #endif
 570:./tmk_core/common/action.c ****             }
 571:./tmk_core/common/action.c **** #endif
 572:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 573:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 574:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 575:./tmk_core/common/action.c ****             break;
 576:./tmk_core/common/action.c **** #endif
 577:./tmk_core/common/action.c ****         default:
 578:./tmk_core/common/action.c ****             break;
 579:./tmk_core/common/action.c ****     }
 580:./tmk_core/common/action.c **** 
 581:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 582:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 583:./tmk_core/common/action.c ****     switch (action.kind.id) {
 584:./tmk_core/common/action.c ****         case ACT_LAYER:
 585:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 586:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 587:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 588:./tmk_core/common/action.c ****         #endif
 589:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 590:./tmk_core/common/action.c ****             break;
 591:./tmk_core/common/action.c ****         default:
 592:./tmk_core/common/action.c ****             break;
 593:./tmk_core/common/action.c ****     }
 594:./tmk_core/common/action.c **** #endif
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 597:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 598:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 599:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 600:./tmk_core/common/action.c ****   } else {
 601:./tmk_core/common/action.c ****     if (event.pressed) {
 602:./tmk_core/common/action.c ****         if (tap_count > 0) {
 603:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 604:./tmk_core/common/action.c ****         } else {
 605:./tmk_core/common/action.c **** 
 606:./tmk_core/common/action.c ****         }
 607:./tmk_core/common/action.c ****     } else {
 608:./tmk_core/common/action.c ****       if (tap_count > 0) {
 609:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 610:./tmk_core/common/action.c ****       } else {
 611:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 612:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 613:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 614:./tmk_core/common/action.c ****         }
 615:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 616:./tmk_core/common/action.c ****       }
 617:./tmk_core/common/action.c ****     }
 618:./tmk_core/common/action.c ****   }
 619:./tmk_core/common/action.c ****   #endif
 620:./tmk_core/common/action.c **** #endif
 621:./tmk_core/common/action.c **** 
 622:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 623:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 624:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 625:./tmk_core/common/action.c ****      */
 626:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 627:./tmk_core/common/action.c ****         record->event.pressed = false;
 628:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 629:./tmk_core/common/action.c ****         process_record(record);
 630:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 631:./tmk_core/common/action.c ****     }
 632:./tmk_core/common/action.c **** #endif
 633:./tmk_core/common/action.c **** }
 634:./tmk_core/common/action.c **** 
 635:./tmk_core/common/action.c **** 
 636:./tmk_core/common/action.c **** 
 637:./tmk_core/common/action.c **** 
 638:./tmk_core/common/action.c **** /*
 639:./tmk_core/common/action.c ****  * Utilities for actions.
 640:./tmk_core/common/action.c ****  */
 641:./tmk_core/common/action.c **** void register_code(uint8_t code)
 642:./tmk_core/common/action.c **** {
 111               		.loc 1 642 0
 112               		.cfi_startproc
 113               	.LVL6:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 643:./tmk_core/common/action.c ****     if (code == KC_NO) {
 118               		.loc 1 643 0
 119 0000 8823      		tst r24
 120 0002 01F4      		brne .+2
 121 0004 00C0      		rjmp .L3
 644:./tmk_core/common/action.c ****         return;
 645:./tmk_core/common/action.c ****     }
 646:./tmk_core/common/action.c **** 
 647:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 648:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 122               		.loc 1 648 0
 123 0006 8238      		cpi r24,lo8(-126)
 124 0008 01F4      		brne .L6
 649:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 650:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 651:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 125               		.loc 1 651 0
 126 000a 0E94 0000 		call host_keyboard_leds
 127               	.LVL7:
 128 000e 81FD      		sbrc r24,1
 129 0010 00C0      		rjmp .L3
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 130               		.loc 1 653 0
 131 0012 89E3      		ldi r24,lo8(57)
 132 0014 0E94 0000 		call add_key
 133               	.LVL8:
 654:./tmk_core/common/action.c ****         send_keyboard_report();
 134               		.loc 1 654 0
 135 0018 0E94 0000 		call send_keyboard_report
 136               	.LVL9:
 137               	.LBB14:
 138               	.LBB15:
 139               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 140               		.loc 2 187 0
 141 001c 2FEF      		ldi r18,lo8(319999)
 142 001e 81EE      		ldi r24,hi8(319999)
 143 0020 94E0      		ldi r25,hlo8(319999)
 144 0022 2150      	1:	subi r18,1
 145 0024 8040      		sbci r24,0
 146 0026 9040      		sbci r25,0
 147 0028 01F4      		brne 1b
 148 002a 00C0      		rjmp .
 149 002c 0000      		nop
 150               	.LVL10:
 151               	.LBE15:
 152               	.LBE14:
 655:./tmk_core/common/action.c ****         wait_ms(100);
 656:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 153               		.loc 1 656 0
 154 002e 89E3      		ldi r24,lo8(57)
 155               	.L38:
 657:./tmk_core/common/action.c ****         send_keyboard_report();
 658:./tmk_core/common/action.c ****     }
 659:./tmk_core/common/action.c **** 
 660:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 661:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 662:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 663:./tmk_core/common/action.c **** #endif
 664:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 665:./tmk_core/common/action.c ****         send_keyboard_report();
 666:./tmk_core/common/action.c ****         wait_ms(100);
 667:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 156               		.loc 1 667 0
 157 0030 0E94 0000 		call del_key
 158               	.LVL11:
 159               	.L39:
 668:./tmk_core/common/action.c ****         send_keyboard_report();
 160               		.loc 1 668 0
 161 0034 0C94 0000 		jmp send_keyboard_report
 162               	.LVL12:
 163               	.L6:
 660:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 164               		.loc 1 660 0
 165 0038 8338      		cpi r24,lo8(-125)
 166 003a 01F4      		brne .L8
 662:./tmk_core/common/action.c **** #endif
 167               		.loc 1 662 0
 168 003c 0E94 0000 		call host_keyboard_leds
 169               	.LVL13:
 170 0040 80FD      		sbrc r24,0
 171 0042 00C0      		rjmp .L3
 664:./tmk_core/common/action.c ****         send_keyboard_report();
 172               		.loc 1 664 0
 173 0044 83E5      		ldi r24,lo8(83)
 174 0046 0E94 0000 		call add_key
 175               	.LVL14:
 665:./tmk_core/common/action.c ****         wait_ms(100);
 176               		.loc 1 665 0
 177 004a 0E94 0000 		call send_keyboard_report
 178               	.LVL15:
 179               	.LBB16:
 180               	.LBB17:
 181               		.loc 2 187 0
 182 004e 2FEF      		ldi r18,lo8(319999)
 183 0050 81EE      		ldi r24,hi8(319999)
 184 0052 94E0      		ldi r25,hlo8(319999)
 185 0054 2150      	1:	subi r18,1
 186 0056 8040      		sbci r24,0
 187 0058 9040      		sbci r25,0
 188 005a 01F4      		brne 1b
 189 005c 00C0      		rjmp .
 190 005e 0000      		nop
 191               	.LVL16:
 192               	.LBE17:
 193               	.LBE16:
 667:./tmk_core/common/action.c ****         send_keyboard_report();
 194               		.loc 1 667 0
 195 0060 83E5      		ldi r24,lo8(83)
 196 0062 00C0      		rjmp .L38
 197               	.LVL17:
 198               	.L8:
 669:./tmk_core/common/action.c ****     }
 670:./tmk_core/common/action.c **** 
 671:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 199               		.loc 1 671 0
 200 0064 8438      		cpi r24,lo8(-124)
 201 0066 01F4      		brne .L9
 672:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 673:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 202               		.loc 1 673 0
 203 0068 0E94 0000 		call host_keyboard_leds
 204               	.LVL18:
 205 006c 82FD      		sbrc r24,2
 206 006e 00C0      		rjmp .L3
 674:./tmk_core/common/action.c **** #endif
 675:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 207               		.loc 1 675 0
 208 0070 87E4      		ldi r24,lo8(71)
 209 0072 0E94 0000 		call add_key
 210               	.LVL19:
 676:./tmk_core/common/action.c ****         send_keyboard_report();
 211               		.loc 1 676 0
 212 0076 0E94 0000 		call send_keyboard_report
 213               	.LVL20:
 214               	.LBB18:
 215               	.LBB19:
 216               		.loc 2 187 0
 217 007a 2FEF      		ldi r18,lo8(319999)
 218 007c 81EE      		ldi r24,hi8(319999)
 219 007e 94E0      		ldi r25,hlo8(319999)
 220 0080 2150      	1:	subi r18,1
 221 0082 8040      		sbci r24,0
 222 0084 9040      		sbci r25,0
 223 0086 01F4      		brne 1b
 224 0088 00C0      		rjmp .
 225 008a 0000      		nop
 226               	.LVL21:
 227               	.LBE19:
 228               	.LBE18:
 677:./tmk_core/common/action.c ****         wait_ms(100);
 678:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 229               		.loc 1 678 0
 230 008c 87E4      		ldi r24,lo8(71)
 231 008e 00C0      		rjmp .L38
 232               	.LVL22:
 233               	.L9:
 679:./tmk_core/common/action.c ****         send_keyboard_report();
 680:./tmk_core/common/action.c ****     }
 681:./tmk_core/common/action.c **** #endif
 682:./tmk_core/common/action.c **** 
 683:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 234               		.loc 1 683 0
 235 0090 9CEF      		ldi r25,lo8(-4)
 236 0092 980F      		add r25,r24
 237 0094 913A      		cpi r25,lo8(-95)
 238 0096 00F4      		brsh .L10
 684:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 685:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 686:./tmk_core/common/action.c **** 
 687:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 688:./tmk_core/common/action.c **** /* TODO: remove
 689:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 690:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 691:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c ****             add_key(code);
 694:./tmk_core/common/action.c ****             send_keyboard_report();
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 697:./tmk_core/common/action.c ****             send_keyboard_report();
 698:./tmk_core/common/action.c ****             oneshot_cancel();
 699:./tmk_core/common/action.c ****         } else
 700:./tmk_core/common/action.c **** */
 701:./tmk_core/common/action.c **** #endif
 702:./tmk_core/common/action.c ****         {
 703:./tmk_core/common/action.c ****             add_key(code);
 239               		.loc 1 703 0
 240 0098 0E94 0000 		call add_key
 241               	.LVL23:
 242 009c 00C0      		rjmp .L39
 243               	.LVL24:
 244               	.L10:
 704:./tmk_core/common/action.c ****             send_keyboard_report();
 705:./tmk_core/common/action.c ****         }
 706:./tmk_core/common/action.c ****     }
 707:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 245               		.loc 1 707 0
 246 009e 90E2      		ldi r25,lo8(32)
 247 00a0 980F      		add r25,r24
 248 00a2 9830      		cpi r25,lo8(8)
 249 00a4 00F4      		brsh .L11
 708:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 250               		.loc 1 708 0
 251 00a6 8770      		andi r24,lo8(7)
 252               	.LVL25:
 253 00a8 91E0      		ldi r25,lo8(1)
 254 00aa 00C0      		rjmp 2f
 255               		1:
 256 00ac 990F      		lsl r25
 257               		2:
 258 00ae 8A95      		dec r24
 259 00b0 02F4      		brpl 1b
 260 00b2 892F      		mov r24,r25
 261 00b4 0E94 0000 		call add_mods
 262               	.LVL26:
 263 00b8 00C0      		rjmp .L39
 264               	.LVL27:
 265               	.L11:
 709:./tmk_core/common/action.c ****         send_keyboard_report();
 710:./tmk_core/common/action.c ****     }
 711:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 266               		.loc 1 711 0
 267 00ba 9BE5      		ldi r25,lo8(91)
 268 00bc 980F      		add r25,r24
 269 00be 9330      		cpi r25,lo8(3)
 270 00c0 00F4      		brsh .L12
 712:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 271               		.loc 1 712 0
 272 00c2 853A      		cpi r24,lo8(-91)
 273 00c4 01F0      		breq .L15
 274               		.loc 1 712 0 is_stmt 0 discriminator 1
 275 00c6 863A      		cpi r24,lo8(-90)
 276 00c8 01F0      		breq .L16
 277               		.loc 1 712 0
 278 00ca 83E8      		ldi r24,lo8(-125)
 279 00cc 90E0      		ldi r25,0
 280               	.LVL28:
 281               	.L13:
 282               		.loc 1 712 0 discriminator 12
 283 00ce 0C94 0000 		jmp host_system_send
 284               	.LVL29:
 285               	.L15:
 286               		.loc 1 712 0
 287 00d2 81E8      		ldi r24,lo8(-127)
 288 00d4 90E0      		ldi r25,0
 289               	.LVL30:
 290 00d6 00C0      		rjmp .L13
 291               	.LVL31:
 292               	.L16:
 293 00d8 82E8      		ldi r24,lo8(-126)
 294 00da 90E0      		ldi r25,0
 295               	.LVL32:
 296 00dc 00C0      		rjmp .L13
 297               	.LVL33:
 298               	.L12:
 713:./tmk_core/common/action.c ****     }
 714:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 299               		.loc 1 714 0 is_stmt 1
 300 00de 98E5      		ldi r25,lo8(88)
 301 00e0 980F      		add r25,r24
 302 00e2 9531      		cpi r25,lo8(21)
 303 00e4 00F0      		brlo .+2
 304 00e6 00C0      		rjmp .L3
 715:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 305               		.loc 1 715 0
 306 00e8 883A      		cpi r24,lo8(-88)
 307 00ea 01F4      		brne .+2
 308 00ec 00C0      		rjmp .L17
 309               		.loc 1 715 0 is_stmt 0 discriminator 1
 310 00ee 893A      		cpi r24,lo8(-87)
 311 00f0 01F4      		brne .+2
 312 00f2 00C0      		rjmp .L18
 313               		.loc 1 715 0 discriminator 3
 314 00f4 8A3A      		cpi r24,lo8(-86)
 315 00f6 01F4      		brne .+2
 316 00f8 00C0      		rjmp .L19
 317               		.loc 1 715 0 discriminator 5
 318 00fa 8B3A      		cpi r24,lo8(-85)
 319 00fc 01F4      		brne .+2
 320 00fe 00C0      		rjmp .L20
 321               		.loc 1 715 0 discriminator 7
 322 0100 8C3A      		cpi r24,lo8(-84)
 323 0102 01F4      		brne .+2
 324 0104 00C0      		rjmp .L21
 325               		.loc 1 715 0 discriminator 9
 326 0106 8B3B      		cpi r24,lo8(-69)
 327 0108 01F4      		brne .+2
 328 010a 00C0      		rjmp .L22
 329               		.loc 1 715 0 discriminator 11
 330 010c 8C3B      		cpi r24,lo8(-68)
 331 010e 01F4      		brne .+2
 332 0110 00C0      		rjmp .L23
 333               		.loc 1 715 0 discriminator 13
 334 0112 8D3A      		cpi r24,lo8(-83)
 335 0114 01F4      		brne .+2
 336 0116 00C0      		rjmp .L24
 337               		.loc 1 715 0 discriminator 15
 338 0118 803B      		cpi r24,lo8(-80)
 339 011a 01F4      		brne .+2
 340 011c 00C0      		rjmp .L25
 341               		.loc 1 715 0 discriminator 17
 342 011e 8E3A      		cpi r24,lo8(-82)
 343 0120 01F4      		brne .+2
 344 0122 00C0      		rjmp .L26
 345               		.loc 1 715 0 discriminator 19
 346 0124 8F3A      		cpi r24,lo8(-81)
 347 0126 01F4      		brne .+2
 348 0128 00C0      		rjmp .L27
 349               		.loc 1 715 0 discriminator 21
 350 012a 813B      		cpi r24,lo8(-79)
 351 012c 01F4      		brne .+2
 352 012e 00C0      		rjmp .L28
 353               		.loc 1 715 0 discriminator 23
 354 0130 823B      		cpi r24,lo8(-78)
 355 0132 01F4      		brne .+2
 356 0134 00C0      		rjmp .L29
 357               		.loc 1 715 0 discriminator 25
 358 0136 833B      		cpi r24,lo8(-77)
 359 0138 01F4      		brne .+2
 360 013a 00C0      		rjmp .L30
 361               		.loc 1 715 0 discriminator 27
 362 013c 843B      		cpi r24,lo8(-76)
 363 013e 01F4      		brne .+2
 364 0140 00C0      		rjmp .L31
 365               		.loc 1 715 0 discriminator 29
 366 0142 853B      		cpi r24,lo8(-75)
 367 0144 01F4      		brne .+2
 368 0146 00C0      		rjmp .L32
 369               		.loc 1 715 0 discriminator 31
 370 0148 863B      		cpi r24,lo8(-74)
 371 014a 01F4      		brne .+2
 372 014c 00C0      		rjmp .L33
 373               		.loc 1 715 0 discriminator 33
 374 014e 873B      		cpi r24,lo8(-73)
 375 0150 01F4      		brne .+2
 376 0152 00C0      		rjmp .L34
 377               		.loc 1 715 0 discriminator 35
 378 0154 883B      		cpi r24,lo8(-72)
 379 0156 01F4      		brne .+2
 380 0158 00C0      		rjmp .L35
 381               		.loc 1 715 0 discriminator 37
 382 015a 893B      		cpi r24,lo8(-71)
 383 015c 01F4      		brne .+2
 384 015e 00C0      		rjmp .L36
 385               		.loc 1 715 0 discriminator 39
 386 0160 8A3B      		cpi r24,lo8(-70)
 387 0162 01F4      		brne .+2
 388 0164 00C0      		rjmp .L37
 389               		.loc 1 715 0
 390 0166 90E0      		ldi r25,0
 391 0168 80E0      		ldi r24,0
 392               	.LVL34:
 393               	.L14:
 394               		.loc 1 715 0 discriminator 84
 395 016a 0C94 0000 		jmp host_consumer_send
 396               	.LVL35:
 397               	.L17:
 398               		.loc 1 715 0
 399 016e 82EE      		ldi r24,lo8(-30)
 400 0170 90E0      		ldi r25,0
 401               	.LVL36:
 402 0172 00C0      		rjmp .L14
 403               	.LVL37:
 404               	.L18:
 405 0174 89EE      		ldi r24,lo8(-23)
 406 0176 90E0      		ldi r25,0
 407               	.LVL38:
 408 0178 00C0      		rjmp .L14
 409               	.LVL39:
 410               	.L19:
 411 017a 8AEE      		ldi r24,lo8(-22)
 412 017c 90E0      		ldi r25,0
 413               	.LVL40:
 414 017e 00C0      		rjmp .L14
 415               	.LVL41:
 416               	.L20:
 417 0180 85EB      		ldi r24,lo8(-75)
 418 0182 90E0      		ldi r25,0
 419               	.LVL42:
 420 0184 00C0      		rjmp .L14
 421               	.LVL43:
 422               	.L21:
 423 0186 86EB      		ldi r24,lo8(-74)
 424 0188 90E0      		ldi r25,0
 425               	.LVL44:
 426 018a 00C0      		rjmp .L14
 427               	.LVL45:
 428               	.L22:
 429 018c 83EB      		ldi r24,lo8(-77)
 430 018e 90E0      		ldi r25,0
 431               	.LVL46:
 432 0190 00C0      		rjmp .L14
 433               	.LVL47:
 434               	.L23:
 435 0192 84EB      		ldi r24,lo8(-76)
 436 0194 90E0      		ldi r25,0
 437               	.LVL48:
 438 0196 00C0      		rjmp .L14
 439               	.LVL49:
 440               	.L24:
 441 0198 87EB      		ldi r24,lo8(-73)
 442 019a 90E0      		ldi r25,0
 443               	.LVL50:
 444 019c 00C0      		rjmp .L14
 445               	.LVL51:
 446               	.L25:
 447 019e 8CEC      		ldi r24,lo8(-52)
 448 01a0 90E0      		ldi r25,0
 449               	.LVL52:
 450 01a2 00C0      		rjmp .L14
 451               	.LVL53:
 452               	.L26:
 453 01a4 8DEC      		ldi r24,lo8(-51)
 454 01a6 90E0      		ldi r25,0
 455               	.LVL54:
 456 01a8 00C0      		rjmp .L14
 457               	.LVL55:
 458               	.L27:
 459 01aa 83E8      		ldi r24,lo8(-125)
 460 01ac 91E0      		ldi r25,lo8(1)
 461               	.LVL56:
 462 01ae 00C0      		rjmp .L14
 463               	.LVL57:
 464               	.L28:
 465 01b0 8AE8      		ldi r24,lo8(-118)
 466 01b2 91E0      		ldi r25,lo8(1)
 467               	.LVL58:
 468 01b4 00C0      		rjmp .L14
 469               	.LVL59:
 470               	.L29:
 471 01b6 82E9      		ldi r24,lo8(-110)
 472 01b8 91E0      		ldi r25,lo8(1)
 473               	.LVL60:
 474 01ba 00C0      		rjmp .L14
 475               	.LVL61:
 476               	.L30:
 477 01bc 84E9      		ldi r24,lo8(-108)
 478 01be 91E0      		ldi r25,lo8(1)
 479               	.LVL62:
 480 01c0 00C0      		rjmp .L14
 481               	.LVL63:
 482               	.L31:
 483 01c2 81E2      		ldi r24,lo8(33)
 484 01c4 92E0      		ldi r25,lo8(2)
 485               	.LVL64:
 486 01c6 00C0      		rjmp .L14
 487               	.LVL65:
 488               	.L32:
 489 01c8 83E2      		ldi r24,lo8(35)
 490 01ca 92E0      		ldi r25,lo8(2)
 491               	.LVL66:
 492 01cc 00C0      		rjmp .L14
 493               	.LVL67:
 494               	.L33:
 495 01ce 84E2      		ldi r24,lo8(36)
 496 01d0 92E0      		ldi r25,lo8(2)
 497               	.LVL68:
 498 01d2 00C0      		rjmp .L14
 499               	.LVL69:
 500               	.L34:
 501 01d4 85E2      		ldi r24,lo8(37)
 502 01d6 92E0      		ldi r25,lo8(2)
 503               	.LVL70:
 504 01d8 00C0      		rjmp .L14
 505               	.LVL71:
 506               	.L35:
 507 01da 86E2      		ldi r24,lo8(38)
 508 01dc 92E0      		ldi r25,lo8(2)
 509               	.LVL72:
 510 01de 00C0      		rjmp .L14
 511               	.LVL73:
 512               	.L36:
 513 01e0 87E2      		ldi r24,lo8(39)
 514 01e2 92E0      		ldi r25,lo8(2)
 515               	.LVL74:
 516 01e4 00C0      		rjmp .L14
 517               	.LVL75:
 518               	.L37:
 519 01e6 8AE2      		ldi r24,lo8(42)
 520 01e8 92E0      		ldi r25,lo8(2)
 521               	.LVL76:
 522 01ea 00C0      		rjmp .L14
 523               	.L3:
 524               	/* epilogue start */
 716:./tmk_core/common/action.c ****     }
 717:./tmk_core/common/action.c **** }
 525               		.loc 1 717 0 is_stmt 1
 526 01ec 0895      		ret
 527               		.cfi_endproc
 528               	.LFE111:
 530               		.section	.text.unregister_code,"ax",@progbits
 531               	.global	unregister_code
 533               	unregister_code:
 534               	.LFB112:
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 720:./tmk_core/common/action.c **** {
 535               		.loc 1 720 0
 536               		.cfi_startproc
 537               	.LVL77:
 538               	/* prologue: function */
 539               	/* frame size = 0 */
 540               	/* stack size = 0 */
 541               	.L__stack_usage = 0
 721:./tmk_core/common/action.c ****     if (code == KC_NO) {
 542               		.loc 1 721 0
 543 0000 8823      		tst r24
 544 0002 01F4      		brne .+2
 545 0004 00C0      		rjmp .L40
 722:./tmk_core/common/action.c ****         return;
 723:./tmk_core/common/action.c ****     }
 724:./tmk_core/common/action.c **** 
 725:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 726:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 546               		.loc 1 726 0
 547 0006 8238      		cpi r24,lo8(-126)
 548 0008 01F4      		brne .L43
 727:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 728:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 729:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 549               		.loc 1 729 0
 550 000a 0E94 0000 		call host_keyboard_leds
 551               	.LVL78:
 552 000e 81FF      		sbrs r24,1
 553 0010 00C0      		rjmp .L40
 730:./tmk_core/common/action.c **** #endif
 731:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 554               		.loc 1 731 0
 555 0012 89E3      		ldi r24,lo8(57)
 556 0014 0E94 0000 		call add_key
 557               	.LVL79:
 732:./tmk_core/common/action.c ****         send_keyboard_report();
 558               		.loc 1 732 0
 559 0018 0E94 0000 		call send_keyboard_report
 560               	.LVL80:
 733:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 561               		.loc 1 733 0
 562 001c 89E3      		ldi r24,lo8(57)
 563               	.L59:
 734:./tmk_core/common/action.c ****         send_keyboard_report();
 735:./tmk_core/common/action.c ****     }
 736:./tmk_core/common/action.c **** 
 737:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 738:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 739:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 742:./tmk_core/common/action.c ****         send_keyboard_report();
 743:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 564               		.loc 1 743 0
 565 001e 0E94 0000 		call del_key
 566               	.LVL81:
 567               	.L60:
 744:./tmk_core/common/action.c ****         send_keyboard_report();
 568               		.loc 1 744 0
 569 0022 0C94 0000 		jmp send_keyboard_report
 570               	.LVL82:
 571               	.L43:
 737:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 572               		.loc 1 737 0
 573 0026 8338      		cpi r24,lo8(-125)
 574 0028 01F4      		brne .L45
 739:./tmk_core/common/action.c **** #endif
 575               		.loc 1 739 0
 576 002a 0E94 0000 		call host_keyboard_leds
 577               	.LVL83:
 578 002e 80FF      		sbrs r24,0
 579 0030 00C0      		rjmp .L40
 741:./tmk_core/common/action.c ****         send_keyboard_report();
 580               		.loc 1 741 0
 581 0032 83E5      		ldi r24,lo8(83)
 582 0034 0E94 0000 		call add_key
 583               	.LVL84:
 742:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 584               		.loc 1 742 0
 585 0038 0E94 0000 		call send_keyboard_report
 586               	.LVL85:
 743:./tmk_core/common/action.c ****         send_keyboard_report();
 587               		.loc 1 743 0
 588 003c 83E5      		ldi r24,lo8(83)
 589 003e 00C0      		rjmp .L59
 590               	.LVL86:
 591               	.L45:
 745:./tmk_core/common/action.c ****     }
 746:./tmk_core/common/action.c **** 
 747:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 592               		.loc 1 747 0
 593 0040 8438      		cpi r24,lo8(-124)
 594 0042 01F4      		brne .L46
 748:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 749:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 595               		.loc 1 749 0
 596 0044 0E94 0000 		call host_keyboard_leds
 597               	.LVL87:
 598 0048 82FF      		sbrs r24,2
 599 004a 00C0      		rjmp .L40
 750:./tmk_core/common/action.c **** #endif
 751:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 600               		.loc 1 751 0
 601 004c 87E4      		ldi r24,lo8(71)
 602 004e 0E94 0000 		call add_key
 603               	.LVL88:
 752:./tmk_core/common/action.c ****         send_keyboard_report();
 604               		.loc 1 752 0
 605 0052 0E94 0000 		call send_keyboard_report
 606               	.LVL89:
 753:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 607               		.loc 1 753 0
 608 0056 87E4      		ldi r24,lo8(71)
 609 0058 00C0      		rjmp .L59
 610               	.LVL90:
 611               	.L46:
 754:./tmk_core/common/action.c ****         send_keyboard_report();
 755:./tmk_core/common/action.c ****     }
 756:./tmk_core/common/action.c **** #endif
 757:./tmk_core/common/action.c **** 
 758:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 612               		.loc 1 758 0
 613 005a 9CEF      		ldi r25,lo8(-4)
 614 005c 980F      		add r25,r24
 615 005e 913A      		cpi r25,lo8(-95)
 616 0060 00F0      		brlo .L59
 759:./tmk_core/common/action.c ****         del_key(code);
 760:./tmk_core/common/action.c ****         send_keyboard_report();
 761:./tmk_core/common/action.c ****     }
 762:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 617               		.loc 1 762 0
 618 0062 90E2      		ldi r25,lo8(32)
 619 0064 980F      		add r25,r24
 620 0066 9830      		cpi r25,lo8(8)
 621 0068 00F4      		brsh .L48
 763:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 622               		.loc 1 763 0
 623 006a 8770      		andi r24,lo8(7)
 624               	.LVL91:
 625 006c 91E0      		ldi r25,lo8(1)
 626 006e 00C0      		rjmp 2f
 627               		1:
 628 0070 990F      		lsl r25
 629               		2:
 630 0072 8A95      		dec r24
 631 0074 02F4      		brpl 1b
 632 0076 892F      		mov r24,r25
 633 0078 0E94 0000 		call del_mods
 634               	.LVL92:
 635 007c 00C0      		rjmp .L60
 636               	.LVL93:
 637               	.L48:
 764:./tmk_core/common/action.c ****         send_keyboard_report();
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 638               		.loc 1 766 0
 639 007e 9BE5      		ldi r25,lo8(91)
 640 0080 980F      		add r25,r24
 641 0082 9330      		cpi r25,lo8(3)
 642 0084 00F4      		brsh .L49
 767:./tmk_core/common/action.c ****         host_system_send(0);
 643               		.loc 1 767 0
 644 0086 90E0      		ldi r25,0
 645 0088 80E0      		ldi r24,0
 646               	.LVL94:
 647 008a 0C94 0000 		jmp host_system_send
 648               	.LVL95:
 649               	.L49:
 768:./tmk_core/common/action.c ****     }
 769:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 650               		.loc 1 769 0
 651 008e 885A      		subi r24,lo8(-(88))
 652               	.LVL96:
 653 0090 8531      		cpi r24,lo8(21)
 654 0092 00F4      		brsh .L40
 770:./tmk_core/common/action.c ****         host_consumer_send(0);
 655               		.loc 1 770 0
 656 0094 90E0      		ldi r25,0
 657 0096 80E0      		ldi r24,0
 658               	.LVL97:
 659 0098 0C94 0000 		jmp host_consumer_send
 660               	.LVL98:
 661               	.L40:
 662               	/* epilogue start */
 771:./tmk_core/common/action.c ****     }
 772:./tmk_core/common/action.c **** }
 663               		.loc 1 772 0
 664 009c 0895      		ret
 665               		.cfi_endproc
 666               	.LFE112:
 668               		.section	.text.register_mods,"ax",@progbits
 669               	.global	register_mods
 671               	register_mods:
 672               	.LFB113:
 773:./tmk_core/common/action.c **** 
 774:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 775:./tmk_core/common/action.c **** {
 673               		.loc 1 775 0
 674               		.cfi_startproc
 675               	.LVL99:
 676               	/* prologue: function */
 677               	/* frame size = 0 */
 678               	/* stack size = 0 */
 679               	.L__stack_usage = 0
 776:./tmk_core/common/action.c ****     if (mods) {
 680               		.loc 1 776 0
 681 0000 8823      		tst r24
 682 0002 01F0      		breq .L61
 777:./tmk_core/common/action.c ****         add_mods(mods);
 683               		.loc 1 777 0
 684 0004 0E94 0000 		call add_mods
 685               	.LVL100:
 778:./tmk_core/common/action.c ****         send_keyboard_report();
 686               		.loc 1 778 0
 687 0008 0C94 0000 		jmp send_keyboard_report
 688               	.LVL101:
 689               	.L61:
 690               	/* epilogue start */
 779:./tmk_core/common/action.c ****     }
 780:./tmk_core/common/action.c **** }
 691               		.loc 1 780 0
 692 000c 0895      		ret
 693               		.cfi_endproc
 694               	.LFE113:
 696               		.section	.text.unregister_mods,"ax",@progbits
 697               	.global	unregister_mods
 699               	unregister_mods:
 700               	.LFB114:
 781:./tmk_core/common/action.c **** 
 782:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 783:./tmk_core/common/action.c **** {
 701               		.loc 1 783 0
 702               		.cfi_startproc
 703               	.LVL102:
 704               	/* prologue: function */
 705               	/* frame size = 0 */
 706               	/* stack size = 0 */
 707               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (mods) {
 708               		.loc 1 784 0
 709 0000 8823      		tst r24
 710 0002 01F0      		breq .L63
 785:./tmk_core/common/action.c ****         del_mods(mods);
 711               		.loc 1 785 0
 712 0004 0E94 0000 		call del_mods
 713               	.LVL103:
 786:./tmk_core/common/action.c ****         send_keyboard_report();
 714               		.loc 1 786 0
 715 0008 0C94 0000 		jmp send_keyboard_report
 716               	.LVL104:
 717               	.L63:
 718               	/* epilogue start */
 787:./tmk_core/common/action.c ****     }
 788:./tmk_core/common/action.c **** }
 719               		.loc 1 788 0
 720 000c 0895      		ret
 721               		.cfi_endproc
 722               	.LFE114:
 724               		.section	.text.process_action,"ax",@progbits
 725               	.global	process_action
 727               	process_action:
 728               	.LFB110:
 154:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 729               		.loc 1 154 0
 730               		.cfi_startproc
 731               	.LVL105:
 732 0000 8F92      		push r8
 733               	.LCFI4:
 734               		.cfi_def_cfa_offset 3
 735               		.cfi_offset 8, -2
 736 0002 9F92      		push r9
 737               	.LCFI5:
 738               		.cfi_def_cfa_offset 4
 739               		.cfi_offset 9, -3
 740 0004 AF92      		push r10
 741               	.LCFI6:
 742               		.cfi_def_cfa_offset 5
 743               		.cfi_offset 10, -4
 744 0006 BF92      		push r11
 745               	.LCFI7:
 746               		.cfi_def_cfa_offset 6
 747               		.cfi_offset 11, -5
 748 0008 DF92      		push r13
 749               	.LCFI8:
 750               		.cfi_def_cfa_offset 7
 751               		.cfi_offset 13, -6
 752 000a EF92      		push r14
 753               	.LCFI9:
 754               		.cfi_def_cfa_offset 8
 755               		.cfi_offset 14, -7
 756 000c FF92      		push r15
 757               	.LCFI10:
 758               		.cfi_def_cfa_offset 9
 759               		.cfi_offset 15, -8
 760 000e 0F93      		push r16
 761               	.LCFI11:
 762               		.cfi_def_cfa_offset 10
 763               		.cfi_offset 16, -9
 764 0010 1F93      		push r17
 765               	.LCFI12:
 766               		.cfi_def_cfa_offset 11
 767               		.cfi_offset 17, -10
 768 0012 CF93      		push r28
 769               	.LCFI13:
 770               		.cfi_def_cfa_offset 12
 771               		.cfi_offset 28, -11
 772 0014 DF93      		push r29
 773               	.LCFI14:
 774               		.cfi_def_cfa_offset 13
 775               		.cfi_offset 29, -12
 776               	/* prologue: function */
 777               	/* frame size = 0 */
 778               	/* stack size = 11 */
 779               	.L__stack_usage = 11
 780 0016 7C01      		movw r14,r24
 781 0018 D62F      		mov r29,r22
 782 001a C72F      		mov r28,r23
 783               	.LVL106:
 157:./tmk_core/common/action.c **** #endif
 784               		.loc 1 157 0
 785 001c FC01      		movw r30,r24
 786 001e 0581      		ldd r16,Z+5
 787 0020 0295      		swap r16
 788 0022 0F70      		andi r16,lo8(15)
 789               	.LVL107:
 160:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 790               		.loc 1 160 0
 791 0024 1281      		ldd r17,Z+2
 792 0026 1111      		cpse r17,__zero_reg__
 162:./tmk_core/common/action.c ****     }
 793               		.loc 1 162 0
 794 0028 0E94 0000 		call clear_weak_mods
 795               	.LVL108:
 796               	.L66:
 168:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 797               		.loc 1 168 0
 798 002c 0E94 0000 		call is_oneshot_layer_active
 799               	.LVL109:
 800 0030 D82E      		mov r13,r24
 801 0032 8823      		tst r24
 802 0034 01F0      		breq .L67
 168:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 803               		.loc 1 168 0 is_stmt 0 discriminator 1
 804 0036 1123      		tst r17
 805 0038 01F0      		breq .L148
 168:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 806               		.loc 1 168 0 discriminator 2
 807 003a 80E2      		ldi r24,lo8(32)
 808 003c 8D0F      		add r24,r29
 809 003e 8830      		cpi r24,lo8(8)
 810 0040 00F0      		brlo .L148
 169:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 811               		.loc 1 169 0 is_stmt 1
 812 0042 82E0      		ldi r24,lo8(2)
 813 0044 0E94 0000 		call clear_oneshot_layer_state
 814               	.LVL110:
 170:./tmk_core/common/action.c ****     }
 815               		.loc 1 170 0
 816 0048 0E94 0000 		call is_oneshot_layer_active
 817               	.LVL111:
 818 004c 91E0      		ldi r25,lo8(1)
 819 004e D82E      		mov r13,r24
 820 0050 D926      		eor r13,r25
 821               	.LVL112:
 822               	.L67:
 174:./tmk_core/common/action.c ****         /* Key and Mods */
 823               		.loc 1 174 0
 824 0052 BC2E      		mov r11,r28
 825 0054 B294      		swap r11
 826 0056 9FE0      		ldi r25,lo8(15)
 827 0058 B922      		and r11,r25
 828 005a EB2D      		mov r30,r11
 829 005c F0E0      		ldi r31,0
 830 005e E050      		subi r30,lo8(-(gs(.L70)))
 831 0060 F040      		sbci r31,hi8(-(gs(.L70)))
 832 0062 0C94 0000 		jmp __tablejump2__
 833               		.p2align	1
 834               	.L70:
 835 0066 0000      		.word gs(.L69)
 836 0068 0000      		.word gs(.L69)
 837 006a 0000      		.word gs(.L71)
 838 006c 0000      		.word gs(.L71)
 839 006e 0000      		.word gs(.L68)
 840 0070 0000      		.word gs(.L72)
 841 0072 0000      		.word gs(.L68)
 842 0074 0000      		.word gs(.L68)
 843 0076 0000      		.word gs(.L73)
 844 0078 0000      		.word gs(.L68)
 845 007a 0000      		.word gs(.L74)
 846 007c 0000      		.word gs(.L74)
 847 007e 0000      		.word gs(.L75)
 848 0080 0000      		.word gs(.L68)
 849 0082 0000      		.word gs(.L68)
 850 0084 0000      		.word gs(.L76)
 851               	.LVL113:
 852               	.L148:
 166:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 853               		.loc 1 166 0
 854 0086 D12C      		mov r13,__zero_reg__
 855 0088 00C0      		rjmp .L67
 856               	.LVL114:
 857               	.L69:
 858 008a 0C2F      		mov r16,r28
 859               	.LVL115:
 860 008c 0F70      		andi r16,lo8(15)
 861               	.LBB20:
 179:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 862               		.loc 1 179 0
 863 008e C07F      		andi r28,lo8(-16)
 864               	.LVL116:
 865 0090 01F0      		breq .L77
 179:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 866               		.loc 1 179 0 is_stmt 0 discriminator 2
 867 0092 0295      		swap r16
 868 0094 007F      		andi r16,lo8(-16)
 869               	.L77:
 870               	.LVL117:
 181:./tmk_core/common/action.c ****                     if (mods) {
 871               		.loc 1 181 0 is_stmt 1 discriminator 4
 872 0096 1123      		tst r17
 873 0098 01F0      		breq .L78
 182:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 874               		.loc 1 182 0
 875 009a 0023      		tst r16
 876 009c 01F0      		breq .L187
 183:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 877               		.loc 1 183 0
 878 009e 80E2      		ldi r24,lo8(32)
 879 00a0 8D0F      		add r24,r29
 880 00a2 8830      		cpi r24,lo8(8)
 881 00a4 00F0      		brlo .L80
 183:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 882               		.loc 1 183 0 is_stmt 0 discriminator 1
 883 00a6 D111      		cpse r29,__zero_reg__
 884 00a8 00C0      		rjmp .L81
 885               	.L80:
 187:./tmk_core/common/action.c ****                         } else {
 886               		.loc 1 187 0 is_stmt 1
 887 00aa 802F      		mov r24,r16
 888 00ac 0E94 0000 		call add_mods
 889               	.LVL118:
 890               	.L82:
 191:./tmk_core/common/action.c ****                     }
 891               		.loc 1 191 0
 892 00b0 0E94 0000 		call send_keyboard_report
 893               	.LVL119:
 894               	.L187:
 895               	.LBE20:
 896               	.LBB21:
 280:./tmk_core/common/action.c ****                                 }
 897               		.loc 1 280 0
 898 00b4 8D2F      		mov r24,r29
 899 00b6 0E94 0000 		call register_code
 900               	.LVL120:
 901 00ba 00C0      		rjmp .L83
 902               	.LVL121:
 903               	.L81:
 904               	.LBE21:
 905               	.LBB22:
 189:./tmk_core/common/action.c ****                         }
 906               		.loc 1 189 0
 907 00bc 802F      		mov r24,r16
 908 00be 0E94 0000 		call add_weak_mods
 909               	.LVL122:
 910 00c2 00C0      		rjmp .L82
 911               	.L78:
 195:./tmk_core/common/action.c ****                     if (mods) {
 912               		.loc 1 195 0
 913 00c4 8D2F      		mov r24,r29
 914 00c6 0E94 0000 		call unregister_code
 915               	.LVL123:
 196:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 916               		.loc 1 196 0
 917 00ca 0023      		tst r16
 918 00cc 01F0      		breq .L83
 197:./tmk_core/common/action.c ****                             del_mods(mods);
 919               		.loc 1 197 0
 920 00ce 80E2      		ldi r24,lo8(32)
 921 00d0 8D0F      		add r24,r29
 922 00d2 8830      		cpi r24,lo8(8)
 923 00d4 00F0      		brlo .L85
 197:./tmk_core/common/action.c ****                             del_mods(mods);
 924               		.loc 1 197 0 is_stmt 0 discriminator 1
 925 00d6 D111      		cpse r29,__zero_reg__
 926 00d8 00C0      		rjmp .L86
 927               	.L85:
 198:./tmk_core/common/action.c ****                         } else {
 928               		.loc 1 198 0 is_stmt 1
 929 00da 802F      		mov r24,r16
 930 00dc 0E94 0000 		call del_mods
 931               	.LVL124:
 932               	.L87:
 202:./tmk_core/common/action.c ****                     }
 933               		.loc 1 202 0
 934 00e0 0E94 0000 		call send_keyboard_report
 935               	.LVL125:
 936               	.L83:
 937               	.LBE22:
 626:./tmk_core/common/action.c ****         record->event.pressed = false;
 938               		.loc 1 626 0
 939 00e4 DD20      		tst r13
 940 00e6 01F4      		brne .+2
 941 00e8 00C0      		rjmp .L65
 626:./tmk_core/common/action.c ****         record->event.pressed = false;
 942               		.loc 1 626 0 is_stmt 0 discriminator 1
 943 00ea 0E94 0000 		call get_oneshot_layer_state
 944               	.LVL126:
 945 00ee 80FD      		sbrc r24,0
 946 00f0 00C0      		rjmp .L65
 627:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 947               		.loc 1 627 0 is_stmt 1
 948 00f2 F701      		movw r30,r14
 949 00f4 1282      		std Z+2,__zero_reg__
 628:./tmk_core/common/action.c ****         process_record(record);
 950               		.loc 1 628 0
 951 00f6 0E94 0000 		call get_oneshot_layer
 952               	.LVL127:
 953 00fa 0E94 0000 		call layer_on
 954               	.LVL128:
 629:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 955               		.loc 1 629 0
 956 00fe C701      		movw r24,r14
 957 0100 0E94 0000 		call process_record
 958               	.LVL129:
 630:./tmk_core/common/action.c ****     }
 959               		.loc 1 630 0
 960 0104 0E94 0000 		call get_oneshot_layer
 961               	.LVL130:
 962               	/* epilogue start */
 633:./tmk_core/common/action.c **** 
 963               		.loc 1 633 0
 964 0108 DF91      		pop r29
 965               	.LVL131:
 966 010a CF91      		pop r28
 967 010c 1F91      		pop r17
 968               	.LVL132:
 969 010e 0F91      		pop r16
 970 0110 FF90      		pop r15
 971 0112 EF90      		pop r14
 972               	.LVL133:
 973 0114 DF90      		pop r13
 974               	.LVL134:
 975 0116 BF90      		pop r11
 976 0118 AF90      		pop r10
 977 011a 9F90      		pop r9
 978 011c 8F90      		pop r8
 630:./tmk_core/common/action.c ****     }
 979               		.loc 1 630 0
 980 011e 0C94 0000 		jmp layer_off
 981               	.LVL135:
 982               	.L86:
 983               	.LBB23:
 200:./tmk_core/common/action.c ****                         }
 984               		.loc 1 200 0
 985 0122 802F      		mov r24,r16
 986 0124 0E94 0000 		call del_weak_mods
 987               	.LVL136:
 988 0128 00C0      		rjmp .L87
 989               	.LVL137:
 990               	.L71:
 991 012a FC2F      		mov r31,r28
 992 012c FF70      		andi r31,lo8(15)
 993 012e BF2E      		mov r11,r31
 994               	.LBE23:
 995               	.LBB24:
 211:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 996               		.loc 1 211 0
 997 0130 C07F      		andi r28,lo8(-16)
 998               	.LVL138:
 999 0132 C032      		cpi r28,lo8(32)
 1000 0134 01F0      		breq .L88
 211:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1001               		.loc 1 211 0 is_stmt 0 discriminator 2
 1002 0136 B294      		swap r11
 1003 0138 80EF      		ldi r24,lo8(-16)
 1004 013a B822      		and r11,r24
 1005               	.L88:
 1006               	.LVL139:
 213:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1007               		.loc 1 213 0 is_stmt 1 discriminator 4
 1008 013c DD23      		tst r29
 1009 013e 01F0      		breq .L90
 1010 0140 D130      		cpi r29,lo8(1)
 1011 0142 01F0      		breq .L91
 268:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1012               		.loc 1 268 0
 1013 0144 1123      		tst r17
 1014 0146 01F0      		breq .L98
 269:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1015               		.loc 1 269 0
 1016 0148 0023      		tst r16
 1017 014a 01F0      		breq .L99
 1018 014c 00C0      		rjmp .L187
 1019               	.L90:
 217:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1020               		.loc 1 217 0
 1021 014e 1123      		tst r17
 1022 0150 01F0      		breq .L92
 218:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1023               		.loc 1 218 0
 1024 0152 0111      		cpse r16,__zero_reg__
 1025 0154 00C0      		rjmp .L93
 1026               	.L99:
 284:./tmk_core/common/action.c ****                             }
 1027               		.loc 1 284 0
 1028 0156 8B2D      		mov r24,r11
 1029               	.L188:
 1030 0158 0E94 0000 		call register_mods
 1031               	.LVL140:
 1032 015c 00C0      		rjmp .L83
 1033               	.L93:
 223:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1034               		.loc 1 223 0
 1035 015e 8B2D      		mov r24,r11
 221:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1036               		.loc 1 221 0
 1037 0160 0130      		cpi r16,lo8(1)
 1038 0162 01F4      		brne .L188
 223:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1039               		.loc 1 223 0
 1040 0164 0E94 0000 		call set_oneshot_mods
 1041               	.LVL141:
 1042 0168 00C0      		rjmp .L83
 1043               	.L92:
 235:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1044               		.loc 1 235 0
 1045 016a 0111      		cpse r16,__zero_reg__
 1046 016c 00C0      		rjmp .L95
 1047               	.L189:
 250:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1048               		.loc 1 250 0
 1049 016e 0E94 0000 		call clear_oneshot_mods
 1050               	.LVL142:
 1051               	.L100:
 292:./tmk_core/common/action.c ****                             }
 1052               		.loc 1 292 0
 1053 0172 8B2D      		mov r24,r11
 1054 0174 0E94 0000 		call unregister_mods
 1055               	.LVL143:
 1056 0178 00C0      		rjmp .L83
 1057               	.L95:
 238:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1058               		.loc 1 238 0
 1059 017a 0130      		cpi r16,lo8(1)
 1060 017c 01F4      		brne .+2
 1061 017e 00C0      		rjmp .L83
 1062 0180 00C0      		rjmp .L189
 1063               	.L91:
 257:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1064               		.loc 1 257 0
 1065 0182 1123      		tst r17
 1066 0184 01F0      		breq .L97
 258:./tmk_core/common/action.c ****                                 register_mods(mods);
 1067               		.loc 1 258 0
 1068 0186 0230      		cpi r16,lo8(2)
 1069 0188 00F0      		brlo .+2
 1070 018a 00C0      		rjmp .L83
 1071 018c 00C0      		rjmp .L99
 1072               	.L97:
 262:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1073               		.loc 1 262 0
 1074 018e 0111      		cpse r16,__zero_reg__
 1075 0190 00C0      		rjmp .L83
 1076 0192 00C0      		rjmp .L100
 1077               	.L98:
 287:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1078               		.loc 1 287 0
 1079 0194 0023      		tst r16
 1080 0196 01F0      		breq .L100
 289:./tmk_core/common/action.c ****                             } else {
 1081               		.loc 1 289 0
 1082 0198 8D2F      		mov r24,r29
 1083 019a 0E94 0000 		call unregister_code
 1084               	.LVL144:
 1085 019e 00C0      		rjmp .L83
 1086               	.LVL145:
 1087               	.L72:
 1088               	.LBE24:
 324:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1089               		.loc 1 324 0
 1090 01a0 1123      		tst r17
 1091 01a2 01F0      		breq .L101
 325:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1092               		.loc 1 325 0
 1093 01a4 D53F      		cpi r29,lo8(-11)
 1094 01a6 01F0      		breq .L103
 1095 01a8 D63F      		cpi r29,lo8(-10)
 1096 01aa 01F0      		breq .L104
 1097 01ac D43F      		cpi r29,lo8(-12)
 1098 01ae 01F4      		brne .L102
 327:./tmk_core/common/action.c ****                         break;
 1099               		.loc 1 327 0
 1100 01b0 8091 0000 		lds r24,tp_buttons
 1101 01b4 9091 0000 		lds r25,tp_buttons+1
 1102 01b8 8160      		ori r24,1
 1103               	.L179:
 333:./tmk_core/common/action.c ****                         break;
 1104               		.loc 1 333 0
 1105 01ba 9093 0000 		sts tp_buttons+1,r25
 1106 01be 8093 0000 		sts tp_buttons,r24
 1107               	.L102:
 338:./tmk_core/common/action.c ****                 mousekey_send();
 1108               		.loc 1 338 0
 1109 01c2 8D2F      		mov r24,r29
 1110 01c4 0E94 0000 		call mousekey_on
 1111               	.LVL146:
 1112               	.L186:
 355:./tmk_core/common/action.c ****             }
 1113               		.loc 1 355 0
 1114 01c8 0E94 0000 		call mousekey_send
 1115               	.LVL147:
 1116 01cc 00C0      		rjmp .L83
 1117               	.L103:
 330:./tmk_core/common/action.c ****                         break;
 1118               		.loc 1 330 0
 1119 01ce 8091 0000 		lds r24,tp_buttons
 1120 01d2 9091 0000 		lds r25,tp_buttons+1
 1121 01d6 8260      		ori r24,2
 1122 01d8 00C0      		rjmp .L179
 1123               	.L104:
 333:./tmk_core/common/action.c ****                         break;
 1124               		.loc 1 333 0
 1125 01da 8091 0000 		lds r24,tp_buttons
 1126 01de 9091 0000 		lds r25,tp_buttons+1
 1127 01e2 8460      		ori r24,4
 1128 01e4 00C0      		rjmp .L179
 1129               	.L101:
 341:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1130               		.loc 1 341 0
 1131 01e6 D53F      		cpi r29,lo8(-11)
 1132 01e8 01F0      		breq .L107
 1133 01ea D63F      		cpi r29,lo8(-10)
 1134 01ec 01F0      		breq .L108
 1135 01ee D43F      		cpi r29,lo8(-12)
 1136 01f0 01F4      		brne .L106
 343:./tmk_core/common/action.c ****                         break;
 1137               		.loc 1 343 0
 1138 01f2 8091 0000 		lds r24,tp_buttons
 1139 01f6 9091 0000 		lds r25,tp_buttons+1
 1140 01fa 8E7F      		andi r24,254
 1141               	.L180:
 349:./tmk_core/common/action.c ****                         break;
 1142               		.loc 1 349 0
 1143 01fc 9093 0000 		sts tp_buttons+1,r25
 1144 0200 8093 0000 		sts tp_buttons,r24
 1145               	.L106:
 354:./tmk_core/common/action.c ****                 mousekey_send();
 1146               		.loc 1 354 0
 1147 0204 8D2F      		mov r24,r29
 1148 0206 0E94 0000 		call mousekey_off
 1149               	.LVL148:
 1150 020a 00C0      		rjmp .L186
 1151               	.L107:
 346:./tmk_core/common/action.c ****                         break;
 1152               		.loc 1 346 0
 1153 020c 8091 0000 		lds r24,tp_buttons
 1154 0210 9091 0000 		lds r25,tp_buttons+1
 1155 0214 8D7F      		andi r24,253
 1156 0216 00C0      		rjmp .L180
 1157               	.L108:
 349:./tmk_core/common/action.c ****                         break;
 1158               		.loc 1 349 0
 1159 0218 8091 0000 		lds r24,tp_buttons
 1160 021c 9091 0000 		lds r25,tp_buttons+1
 1161 0220 8B7F      		andi r24,251
 1162 0222 00C0      		rjmp .L180
 1163               	.L73:
 361:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1164               		.loc 1 361 0
 1165 0224 8C2F      		mov r24,r28
 1166 0226 8370      		andi r24,lo8(3)
 1167 0228 01F0      		breq .+2
 1168 022a 00C0      		rjmp .L110
 363:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1169               		.loc 1 363 0
 1170 022c 1111      		cpse r17,__zero_reg__
 1171 022e 00C0      		rjmp .L111
 1172               	.LVL149:
 1173               	.LBB25:
 364:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1174               		.loc 1 364 0
 1175 0230 2D2F      		mov r18,r29
 1176 0232 2295      		swap r18
 1177 0234 2695      		lsr r18
 1178 0236 2770      		andi r18,lo8(7)
 1179 0238 220F      		lsl r18
 1180 023a 220F      		lsl r18
 365:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1181               		.loc 1 365 0
 1182 023c 6D2F      		mov r22,r29
 1183 023e 6F70      		andi r22,lo8(15)
 1184 0240 862E      		mov r8,r22
 1185 0242 912C      		mov r9,__zero_reg__
 1186 0244 B12C      		mov r11,__zero_reg__
 1187 0246 A12C      		mov r10,__zero_reg__
 1188 0248 022E      		mov r0,r18
 1189 024a 00C0      		rjmp 2f
 1190               		1:
 1191 024c 880C      		lsl r8
 1192 024e 991C      		rol r9
 1193 0250 AA1C      		rol r10
 1194 0252 BB1C      		rol r11
 1195               		2:
 1196 0254 0A94      		dec r0
 1197 0256 02F4      		brpl 1b
 1198               	.LVL150:
 366:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1199               		.loc 1 366 0
 1200 0258 60E0      		ldi r22,0
 1201 025a 70E0      		ldi r23,0
 1202 025c CB01      		movw r24,r22
 1203 025e D4FF      		sbrs r29,4
 1204 0260 00C0      		rjmp .L112
 366:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1205               		.loc 1 366 0 is_stmt 0 discriminator 1
 1206 0262 6FE0      		ldi r22,lo8(15)
 1207 0264 70E0      		ldi r23,0
 1208 0266 80E0      		ldi r24,0
 1209 0268 90E0      		ldi r25,0
 1210 026a 00C0      		rjmp 2f
 1211               		1:
 1212 026c 660F      		lsl r22
 1213 026e 771F      		rol r23
 1214 0270 881F      		rol r24
 1215 0272 991F      		rol r25
 1216               		2:
 1217 0274 2A95      		dec r18
 1218 0276 02F4      		brpl 1b
 1219 0278 6095      		com r22
 1220 027a 7095      		com r23
 1221 027c 8095      		com r24
 1222 027e 9095      		com r25
 1223               	.L112:
 1224               	.LVL151:
 367:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1225               		.loc 1 367 0 is_stmt 1 discriminator 4
 1226 0280 C695      		lsr r28
 1227 0282 C695      		lsr r28
 1228               	.LVL152:
 1229 0284 C370      		andi r28,lo8(3)
 1230 0286 C230      		cpi r28,lo8(2)
 1231 0288 01F0      		breq .L114
 1232 028a 00F4      		brsh .L115
 1233 028c 6829      		or r22,r8
 1234               	.LVL153:
 1235 028e 7929      		or r23,r9
 1236 0290 8A29      		or r24,r10
 1237 0292 9B29      		or r25,r11
 1238 0294 C130      		cpi r28,lo8(1)
 1239 0296 01F0      		breq .L185
 368:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1240               		.loc 1 368 0 discriminator 4
 1241 0298 0E94 0000 		call default_layer_and
 1242               	.LVL154:
 1243               	.L111:
 1244               	.LBE25:
 589:./tmk_core/common/action.c ****             break;
 1245               		.loc 1 589 0
 1246 029c 0E94 0000 		call host_keyboard_leds
 1247               	.LVL155:
 1248 02a0 0E94 0000 		call led_set
 1249               	.LVL156:
 590:./tmk_core/common/action.c ****         default:
 1250               		.loc 1 590 0
 1251 02a4 00C0      		rjmp .L83
 1252               	.LVL157:
 1253               	.L114:
 1254               	.LBB26:
 370:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1255               		.loc 1 370 0
 1256 02a6 6829      		or r22,r8
 1257               	.LVL158:
 1258 02a8 7929      		or r23,r9
 1259 02aa 8A29      		or r24,r10
 1260 02ac 9B29      		or r25,r11
 1261 02ae 0E94 0000 		call default_layer_xor
 1262               	.LVL159:
 1263 02b2 00C0      		rjmp .L111
 1264               	.LVL160:
 1265               	.L115:
 371:./tmk_core/common/action.c ****                     }
 1266               		.loc 1 371 0
 1267 02b4 0E94 0000 		call default_layer_and
 1268               	.LVL161:
 1269 02b8 C501      		movw r24,r10
 1270 02ba B401      		movw r22,r8
 1271               	.L185:
 1272 02bc 0E94 0000 		call default_layer_or
 1273               	.LVL162:
 1274 02c0 00C0      		rjmp .L111
 1275               	.LVL163:
 1276               	.L110:
 1277               	.LBE26:
 376:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1278               		.loc 1 376 0
 1279 02c2 8695      		lsr r24
 1280 02c4 1123      		tst r17
 1281 02c6 01F0      		breq .L118
 376:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1282               		.loc 1 376 0 is_stmt 0 discriminator 1
 1283 02c8 8C2F      		mov r24,r28
 1284 02ca 8170      		andi r24,lo8(1)
 1285               	.L118:
 376:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1286               		.loc 1 376 0 discriminator 4
 1287 02cc 8823      		tst r24
 1288 02ce 01F0      		breq .L111
 1289               	.LVL164:
 1290               	.LBB27:
 378:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1291               		.loc 1 378 0 is_stmt 1
 1292 02d0 2D2F      		mov r18,r29
 1293 02d2 2295      		swap r18
 1294 02d4 2695      		lsr r18
 1295 02d6 2770      		andi r18,lo8(7)
 1296 02d8 220F      		lsl r18
 1297 02da 220F      		lsl r18
 379:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1298               		.loc 1 379 0
 1299 02dc 6D2F      		mov r22,r29
 1300 02de 6F70      		andi r22,lo8(15)
 1301 02e0 862E      		mov r8,r22
 1302 02e2 912C      		mov r9,__zero_reg__
 1303 02e4 B12C      		mov r11,__zero_reg__
 1304 02e6 A12C      		mov r10,__zero_reg__
 1305 02e8 022E      		mov r0,r18
 1306 02ea 00C0      		rjmp 2f
 1307               		1:
 1308 02ec 880C      		lsl r8
 1309 02ee 991C      		rol r9
 1310 02f0 AA1C      		rol r10
 1311 02f2 BB1C      		rol r11
 1312               		2:
 1313 02f4 0A94      		dec r0
 1314 02f6 02F4      		brpl 1b
 1315               	.LVL165:
 380:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1316               		.loc 1 380 0
 1317 02f8 60E0      		ldi r22,0
 1318 02fa 70E0      		ldi r23,0
 1319 02fc CB01      		movw r24,r22
 1320 02fe D4FF      		sbrs r29,4
 1321 0300 00C0      		rjmp .L119
 380:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1322               		.loc 1 380 0 is_stmt 0 discriminator 1
 1323 0302 6FE0      		ldi r22,lo8(15)
 1324 0304 70E0      		ldi r23,0
 1325 0306 80E0      		ldi r24,0
 1326 0308 90E0      		ldi r25,0
 1327 030a 00C0      		rjmp 2f
 1328               		1:
 1329 030c 660F      		lsl r22
 1330 030e 771F      		rol r23
 1331 0310 881F      		rol r24
 1332 0312 991F      		rol r25
 1333               		2:
 1334 0314 2A95      		dec r18
 1335 0316 02F4      		brpl 1b
 1336 0318 6095      		com r22
 1337 031a 7095      		com r23
 1338 031c 8095      		com r24
 1339 031e 9095      		com r25
 1340               	.L119:
 1341               	.LVL166:
 381:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1342               		.loc 1 381 0 is_stmt 1 discriminator 4
 1343 0320 C695      		lsr r28
 1344 0322 C695      		lsr r28
 1345               	.LVL167:
 1346 0324 C370      		andi r28,lo8(3)
 1347 0326 C230      		cpi r28,lo8(2)
 1348 0328 01F0      		breq .L121
 1349 032a 00F4      		brsh .L122
 1350 032c 6829      		or r22,r8
 1351               	.LVL168:
 1352 032e 7929      		or r23,r9
 1353 0330 8A29      		or r24,r10
 1354 0332 9B29      		or r25,r11
 1355 0334 C130      		cpi r28,lo8(1)
 1356 0336 01F0      		breq .L184
 382:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1357               		.loc 1 382 0 discriminator 4
 1358 0338 0E94 0000 		call layer_and
 1359               	.LVL169:
 1360 033c 00C0      		rjmp .L111
 1361               	.LVL170:
 1362               	.L121:
 384:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1363               		.loc 1 384 0
 1364 033e 6829      		or r22,r8
 1365               	.LVL171:
 1366 0340 7929      		or r23,r9
 1367 0342 8A29      		or r24,r10
 1368 0344 9B29      		or r25,r11
 1369 0346 0E94 0000 		call layer_xor
 1370               	.LVL172:
 1371 034a 00C0      		rjmp .L111
 1372               	.LVL173:
 1373               	.L122:
 385:./tmk_core/common/action.c ****                     }
 1374               		.loc 1 385 0
 1375 034c 0E94 0000 		call layer_and
 1376               	.LVL174:
 1377 0350 C501      		movw r24,r10
 1378 0352 B401      		movw r22,r8
 1379               	.L184:
 1380 0354 0E94 0000 		call layer_or
 1381               	.LVL175:
 1382 0358 00C0      		rjmp .L111
 1383               	.LVL176:
 1384               	.L74:
 1385               	.LBE27:
 393:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1386               		.loc 1 393 0
 1387 035a E0E2      		ldi r30,lo8(32)
 1388 035c ED0F      		add r30,r29
 1389 035e E531      		cpi r30,lo8(21)
 1390 0360 00F0      		brlo .+2
 1391 0362 00C0      		rjmp .L124
 1392 0364 F0E0      		ldi r31,0
 1393 0366 E050      		subi r30,lo8(-(gs(.L126)))
 1394 0368 F040      		sbci r31,hi8(-(gs(.L126)))
 1395 036a 0C94 0000 		jmp __tablejump2__
 1396               		.p2align	1
 1397               	.L126:
 1398 036e 0000      		.word gs(.L125)
 1399 0370 0000      		.word gs(.L125)
 1400 0372 0000      		.word gs(.L125)
 1401 0374 0000      		.word gs(.L125)
 1402 0376 0000      		.word gs(.L125)
 1403 0378 0000      		.word gs(.L125)
 1404 037a 0000      		.word gs(.L125)
 1405 037c 0000      		.word gs(.L125)
 1406 037e 0000      		.word gs(.L125)
 1407 0380 0000      		.word gs(.L125)
 1408 0382 0000      		.word gs(.L125)
 1409 0384 0000      		.word gs(.L125)
 1410 0386 0000      		.word gs(.L125)
 1411 0388 0000      		.word gs(.L125)
 1412 038a 0000      		.word gs(.L125)
 1413 038c 0000      		.word gs(.L125)
 1414 038e 0000      		.word gs(.L127)
 1415 0390 0000      		.word gs(.L128)
 1416 0392 0000      		.word gs(.L129)
 1417 0394 0000      		.word gs(.L130)
 1418 0396 0000      		.word gs(.L131)
 1419               	.L125:
 1420 0398 DF70      		andi r29,lo8(15)
 1421               	.LVL177:
 1422 039a 8C2F      		mov r24,r28
 1423 039c 8F71      		andi r24,lo8(31)
 396:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1424               		.loc 1 396 0
 1425 039e 1123      		tst r17
 1426 03a0 01F0      		breq .L132
 397:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1427               		.loc 1 397 0
 1428 03a2 0E94 0000 		call layer_on
 1429               	.LVL178:
 398:./tmk_core/common/action.c ****                     } else {
 1430               		.loc 1 398 0
 1431 03a6 8D2F      		mov r24,r29
 1432 03a8 0E94 0000 		call register_mods
 1433               	.LVL179:
 1434               	.L68:
 583:./tmk_core/common/action.c ****         case ACT_LAYER:
 1435               		.loc 1 583 0
 1436 03ac E8E0      		ldi r30,lo8(8)
 1437 03ae BE16      		cp r11,r30
 1438 03b0 01F4      		brne .+2
 1439 03b2 00C0      		rjmp .L111
 1440 03b4 BE16      		cp r11,r30
 1441 03b6 00F4      		brsh .+2
 1442 03b8 00C0      		rjmp .L83
 1443 03ba 86EF      		ldi r24,lo8(-10)
 1444 03bc 8B0D      		add r24,r11
 1445 03be 8230      		cpi r24,lo8(2)
 1446 03c0 00F4      		brsh .+2
 1447 03c2 00C0      		rjmp .L111
 1448 03c4 00C0      		rjmp .L83
 1449               	.LVL180:
 1450               	.L132:
 400:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1451               		.loc 1 400 0
 1452 03c6 0E94 0000 		call layer_off
 1453               	.LVL181:
 401:./tmk_core/common/action.c ****                     }
 1454               		.loc 1 401 0
 1455 03ca 8D2F      		mov r24,r29
 1456 03cc 0E94 0000 		call unregister_mods
 1457               	.LVL182:
 1458 03d0 00C0      		rjmp .L68
 1459               	.LVL183:
 1460               	.L127:
 406:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1461               		.loc 1 406 0
 1462 03d2 1123      		tst r17
 1463 03d4 01F0      		breq .L133
 407:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1464               		.loc 1 407 0
 1465 03d6 0111      		cpse r16,__zero_reg__
 1466 03d8 00C0      		rjmp .L68
 1467               	.L134:
 408:./tmk_core/common/action.c ****                         }
 1468               		.loc 1 408 0
 1469 03da 8C2F      		mov r24,r28
 1470 03dc 8F71      		andi r24,lo8(31)
 1471 03de 0E94 0000 		call layer_invert
 1472               	.LVL184:
 1473 03e2 00C0      		rjmp .L68
 1474               	.L133:
 411:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1475               		.loc 1 411 0
 1476 03e4 0230      		cpi r16,lo8(2)
 1477 03e6 00F4      		brsh .L68
 1478 03e8 00C0      		rjmp .L134
 1479               	.L128:
 1480 03ea 8C2F      		mov r24,r28
 1481 03ec 8F71      		andi r24,lo8(31)
 417:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1482               		.loc 1 417 0
 1483 03ee 1123      		tst r17
 1484 03f0 01F0      		breq .L183
 1485               	.L182:
 474:./tmk_core/common/action.c ****                         }
 1486               		.loc 1 474 0
 1487 03f2 0E94 0000 		call layer_on
 1488               	.LVL185:
 1489 03f6 00C0      		rjmp .L68
 1490               	.L129:
 1491 03f8 8C2F      		mov r24,r28
 1492 03fa 8F71      		andi r24,lo8(31)
 421:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1493               		.loc 1 421 0
 1494 03fc 1123      		tst r17
 1495 03fe 01F0      		breq .L182
 1496               	.L183:
 485:./tmk_core/common/action.c ****                         }
 1497               		.loc 1 485 0
 1498 0400 0E94 0000 		call layer_off
 1499               	.LVL186:
 1500 0404 00C0      		rjmp .L68
 1501               	.L130:
 425:./tmk_core/common/action.c ****                                     layer_clear();
 1502               		.loc 1 425 0
 1503 0406 1123      		tst r17
 1504 0408 01F0      		breq .L138
 425:./tmk_core/common/action.c ****                                     layer_clear();
 1505               		.loc 1 425 0 is_stmt 0 discriminator 1
 1506 040a 8C2F      		mov r24,r28
 1507 040c 8F71      		andi r24,lo8(31)
 1508 040e 0E94 0000 		call layer_move
 1509               	.LVL187:
 1510 0412 00C0      		rjmp .L68
 1511               	.L138:
 426:./tmk_core/common/action.c ****                     break;
 1512               		.loc 1 426 0 is_stmt 1
 1513 0414 0E94 0000 		call layer_clear
 1514               	.LVL188:
 1515 0418 00C0      		rjmp .L68
 1516               	.L131:
 454:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1517               		.loc 1 454 0
 1518 041a 1123      		tst r17
 1519 041c 01F0      		breq .L139
 455:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1520               		.loc 1 455 0
 1521 041e CF71      		andi r28,lo8(31)
 1522               	.LVL189:
 1523 0420 8C2F      		mov r24,r28
 1524 0422 0E94 0000 		call layer_on
 1525               	.LVL190:
 456:./tmk_core/common/action.c ****                     } else {
 1526               		.loc 1 456 0
 1527 0426 63E0      		ldi r22,lo8(3)
 1528 0428 8C2F      		mov r24,r28
 1529 042a 0E94 0000 		call set_oneshot_layer
 1530               	.LVL191:
 1531 042e 00C0      		rjmp .L68
 1532               	.LVL192:
 1533               	.L139:
 458:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1534               		.loc 1 458 0
 1535 0430 81E0      		ldi r24,lo8(1)
 1536 0432 0E94 0000 		call clear_oneshot_layer_state
 1537               	.LVL193:
 459:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1538               		.loc 1 459 0
 1539 0436 0230      		cpi r16,lo8(2)
 1540 0438 00F4      		brsh .+2
 1541 043a 00C0      		rjmp .L68
 460:./tmk_core/common/action.c ****                         }
 1542               		.loc 1 460 0
 1543 043c 82E0      		ldi r24,lo8(2)
 1544 043e 0E94 0000 		call clear_oneshot_layer_state
 1545               	.LVL194:
 1546 0442 00C0      		rjmp .L68
 1547               	.L124:
 468:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1548               		.loc 1 468 0
 1549 0444 1123      		tst r17
 1550 0446 01F0      		breq .L140
 469:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1551               		.loc 1 469 0
 1552 0448 0023      		tst r16
 1553 044a 01F0      		breq .L141
 471:./tmk_core/common/action.c ****                         } else {
 1554               		.loc 1 471 0
 1555 044c 8D2F      		mov r24,r29
 1556 044e 0E94 0000 		call register_code
 1557               	.LVL195:
 1558 0452 00C0      		rjmp .L68
 1559               	.L141:
 474:./tmk_core/common/action.c ****                         }
 1560               		.loc 1 474 0
 1561 0454 8C2F      		mov r24,r28
 1562 0456 8F71      		andi r24,lo8(31)
 1563 0458 00C0      		rjmp .L182
 1564               	.L140:
 477:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1565               		.loc 1 477 0
 1566 045a 0023      		tst r16
 1567 045c 01F0      		breq .L142
 479:./tmk_core/common/action.c ****                                 wait_ms(80);
 1568               		.loc 1 479 0
 1569 045e D933      		cpi r29,lo8(57)
 1570 0460 01F4      		brne .L143
 1571               	.LVL196:
 1572               	.LBB28:
 1573               	.LBB29:
 1574               		.loc 2 187 0
 1575 0462 2FEF      		ldi r18,lo8(255999)
 1576 0464 87EE      		ldi r24,hi8(255999)
 1577 0466 93E0      		ldi r25,hlo8(255999)
 1578 0468 2150      	1:	subi r18,1
 1579 046a 8040      		sbci r24,0
 1580 046c 9040      		sbci r25,0
 1581 046e 01F4      		brne 1b
 1582 0470 00C0      		rjmp .
 1583 0472 0000      		nop
 1584               	.LVL197:
 1585               	.L143:
 1586               	.LBE29:
 1587               	.LBE28:
 482:./tmk_core/common/action.c ****                         } else {
 1588               		.loc 1 482 0
 1589 0474 8D2F      		mov r24,r29
 1590 0476 0E94 0000 		call unregister_code
 1591               	.LVL198:
 1592 047a 00C0      		rjmp .L68
 1593               	.L142:
 485:./tmk_core/common/action.c ****                         }
 1594               		.loc 1 485 0
 1595 047c 8C2F      		mov r24,r28
 1596 047e 8F71      		andi r24,lo8(31)
 1597 0480 00C0      		rjmp .L183
 1598               	.L75:
 496:./tmk_core/common/action.c ****             break;
 1599               		.loc 1 496 0
 1600 0482 4C2F      		mov r20,r28
 1601 0484 4F70      		andi r20,lo8(15)
 1602 0486 6D2F      		mov r22,r29
 1603 0488 C701      		movw r24,r14
 1604 048a 0E94 0000 		call action_get_macro
 1605               	.LVL199:
 1606 048e 0E94 0000 		call action_macro_play
 1607               	.LVL200:
 497:./tmk_core/common/action.c **** #endif
 1608               		.loc 1 497 0
 1609 0492 00C0      		rjmp .L83
 1610               	.L76:
 574:./tmk_core/common/action.c ****             break;
 1611               		.loc 1 574 0
 1612 0494 4C2F      		mov r20,r28
 1613 0496 4F70      		andi r20,lo8(15)
 1614 0498 6D2F      		mov r22,r29
 1615 049a C701      		movw r24,r14
 1616 049c 0E94 0000 		call action_function
 1617               	.LVL201:
 575:./tmk_core/common/action.c **** #endif
 1618               		.loc 1 575 0
 1619 04a0 00C0      		rjmp .L83
 1620               	.LVL202:
 1621               	.L65:
 1622               	/* epilogue start */
 633:./tmk_core/common/action.c **** 
 1623               		.loc 1 633 0
 1624 04a2 DF91      		pop r29
 1625               	.LVL203:
 1626 04a4 CF91      		pop r28
 1627 04a6 1F91      		pop r17
 1628               	.LVL204:
 1629 04a8 0F91      		pop r16
 1630 04aa FF90      		pop r15
 1631 04ac EF90      		pop r14
 1632               	.LVL205:
 1633 04ae DF90      		pop r13
 1634               	.LVL206:
 1635 04b0 BF90      		pop r11
 1636 04b2 AF90      		pop r10
 1637 04b4 9F90      		pop r9
 1638 04b6 8F90      		pop r8
 1639 04b8 0895      		ret
 1640               		.cfi_endproc
 1641               	.LFE110:
 1643               		.section	.text.process_record,"ax",@progbits
 1644               	.global	process_record
 1646               	process_record:
 1647               	.LFB109:
 136:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1648               		.loc 1 136 0
 1649               		.cfi_startproc
 1650               	.LVL207:
 1651 0000 0F93      		push r16
 1652               	.LCFI15:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 16, -2
 1655 0002 1F93      		push r17
 1656               	.LCFI16:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 17, -3
 1659 0004 CF93      		push r28
 1660               	.LCFI17:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 28, -4
 1663 0006 DF93      		push r29
 1664               	.LCFI18:
 1665               		.cfi_def_cfa_offset 6
 1666               		.cfi_offset 29, -5
 1667               	/* prologue: function */
 1668               	/* frame size = 0 */
 1669               	/* stack size = 4 */
 1670               	.L__stack_usage = 4
 1671 0008 EC01      		movw r28,r24
 1672 000a 9881      		ld r25,Y
 1673 000c 8981      		ldd r24,Y+1
 1674               	.LVL208:
 1675               	.LBB32:
 1676               	.LBB33:
 1677               		.file 3 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1678               		.loc 3 49 0
 1679 000e 2B81      		ldd r18,Y+3
 1680 0010 3C81      		ldd r19,Y+4
 1681 0012 232B      		or r18,r19
 1682 0014 01F0      		breq .L194
 1683 0016 8F3F      		cpi r24,lo8(-1)
 1684 0018 01F4      		brne .L195
 1685 001a 81E0      		ldi r24,lo8(1)
 1686 001c 9F3F      		cpi r25,lo8(-1)
 1687 001e 01F0      		breq .L191
 1688               	.L195:
 1689 0020 80E0      		ldi r24,0
 1690 0022 00C0      		rjmp .L191
 1691               	.L194:
 1692 0024 81E0      		ldi r24,lo8(1)
 1693               	.L191:
 1694               	.LBE33:
 1695               	.LBE32:
 137:./tmk_core/common/action.c **** 
 1696               		.loc 1 137 0
 1697 0026 80FD      		sbrc r24,0
 1698 0028 00C0      		rjmp .L190
 139:./tmk_core/common/action.c ****         return;
 1699               		.loc 1 139 0
 1700 002a CE01      		movw r24,r28
 1701 002c 0E94 0000 		call process_record_quantum
 1702               	.LVL209:
 1703 0030 8823      		tst r24
 1704 0032 01F0      		breq .L190
 142:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1705               		.loc 1 142 0
 1706 0034 6881      		ld r22,Y
 1707 0036 7981      		ldd r23,Y+1
 1708 0038 8A81      		ldd r24,Y+2
 1709 003a 0E94 0000 		call store_or_get_action
 1710               	.LVL210:
 1711 003e 8C01      		movw r16,r24
 1712               	.LVL211:
 145:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1713               		.loc 1 145 0
 1714 0040 0E94 0000 		call layer_debug
 1715               	.LVL212:
 146:./tmk_core/common/action.c **** #endif
 1716               		.loc 1 146 0
 1717 0044 0E94 0000 		call default_layer_debug
 1718               	.LVL213:
 150:./tmk_core/common/action.c **** }
 1719               		.loc 1 150 0
 1720 0048 B801      		movw r22,r16
 1721 004a CE01      		movw r24,r28
 1722               	/* epilogue start */
 151:./tmk_core/common/action.c **** 
 1723               		.loc 1 151 0
 1724 004c DF91      		pop r29
 1725 004e CF91      		pop r28
 1726               	.LVL214:
 1727 0050 1F91      		pop r17
 1728 0052 0F91      		pop r16
 1729               	.LVL215:
 150:./tmk_core/common/action.c **** }
 1730               		.loc 1 150 0
 1731 0054 0C94 0000 		jmp process_action
 1732               	.LVL216:
 1733               	.L190:
 1734               	/* epilogue start */
 151:./tmk_core/common/action.c **** 
 1735               		.loc 1 151 0
 1736 0058 DF91      		pop r29
 1737 005a CF91      		pop r28
 1738               	.LVL217:
 1739 005c 1F91      		pop r17
 1740 005e 0F91      		pop r16
 1741 0060 0895      		ret
 1742               		.cfi_endproc
 1743               	.LFE109:
 1745               		.section	.text.process_record_nocache,"ax",@progbits
 1746               	.global	process_record_nocache
 1748               	process_record_nocache:
 1749               	.LFB107:
 118:./tmk_core/common/action.c ****     disable_action_cache = true;
 1750               		.loc 1 118 0
 1751               		.cfi_startproc
 1752               	.LVL218:
 1753               	/* prologue: function */
 1754               	/* frame size = 0 */
 1755               	/* stack size = 0 */
 1756               	.L__stack_usage = 0
 119:./tmk_core/common/action.c ****     process_record(record);
 1757               		.loc 1 119 0
 1758 0000 21E0      		ldi r18,lo8(1)
 1759 0002 2093 0000 		sts disable_action_cache,r18
 120:./tmk_core/common/action.c ****     disable_action_cache = false;
 1760               		.loc 1 120 0
 1761 0006 0E94 0000 		call process_record
 1762               	.LVL219:
 121:./tmk_core/common/action.c **** }
 1763               		.loc 1 121 0
 1764 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1765               	/* epilogue start */
 122:./tmk_core/common/action.c **** #else
 1766               		.loc 1 122 0
 1767 000e 0895      		ret
 1768               		.cfi_endproc
 1769               	.LFE107:
 1771               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1772               	.global	clear_keyboard_but_mods
 1774               	clear_keyboard_but_mods:
 1775               	.LFB116:
 789:./tmk_core/common/action.c **** 
 790:./tmk_core/common/action.c **** void clear_keyboard(void)
 791:./tmk_core/common/action.c **** {
 792:./tmk_core/common/action.c ****     clear_mods();
 793:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 794:./tmk_core/common/action.c **** }
 795:./tmk_core/common/action.c **** 
 796:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 797:./tmk_core/common/action.c **** {
 1776               		.loc 1 797 0
 1777               		.cfi_startproc
 1778               	/* prologue: function */
 1779               	/* frame size = 0 */
 1780               	/* stack size = 0 */
 1781               	.L__stack_usage = 0
 798:./tmk_core/common/action.c ****     clear_weak_mods();
 1782               		.loc 1 798 0
 1783 0000 0E94 0000 		call clear_weak_mods
 1784               	.LVL220:
 799:./tmk_core/common/action.c ****     clear_macro_mods();
 1785               		.loc 1 799 0
 1786 0004 0E94 0000 		call clear_macro_mods
 1787               	.LVL221:
 800:./tmk_core/common/action.c ****     clear_keys();
 1788               		.loc 1 800 0
 1789 0008 0E94 0000 		call clear_keys
 1790               	.LVL222:
 801:./tmk_core/common/action.c ****     send_keyboard_report();
 1791               		.loc 1 801 0
 1792 000c 0E94 0000 		call send_keyboard_report
 1793               	.LVL223:
 802:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 803:./tmk_core/common/action.c ****     mousekey_clear();
 1794               		.loc 1 803 0
 1795 0010 0E94 0000 		call mousekey_clear
 1796               	.LVL224:
 804:./tmk_core/common/action.c ****     mousekey_send();
 1797               		.loc 1 804 0
 1798 0014 0C94 0000 		jmp mousekey_send
 1799               	.LVL225:
 1800               		.cfi_endproc
 1801               	.LFE116:
 1803               		.section	.text.clear_keyboard,"ax",@progbits
 1804               	.global	clear_keyboard
 1806               	clear_keyboard:
 1807               	.LFB115:
 791:./tmk_core/common/action.c ****     clear_mods();
 1808               		.loc 1 791 0
 1809               		.cfi_startproc
 1810               	/* prologue: function */
 1811               	/* frame size = 0 */
 1812               	/* stack size = 0 */
 1813               	.L__stack_usage = 0
 792:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1814               		.loc 1 792 0
 1815 0000 0E94 0000 		call clear_mods
 1816               	.LVL226:
 793:./tmk_core/common/action.c **** }
 1817               		.loc 1 793 0
 1818 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1819               	.LVL227:
 1820               		.cfi_endproc
 1821               	.LFE115:
 1823               		.section	.text.is_tap_key,"ax",@progbits
 1824               	.global	is_tap_key
 1826               	is_tap_key:
 1827               	.LFB117:
 805:./tmk_core/common/action.c **** #endif
 806:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 807:./tmk_core/common/action.c ****     host_system_send(0);
 808:./tmk_core/common/action.c ****     host_consumer_send(0);
 809:./tmk_core/common/action.c **** #endif
 810:./tmk_core/common/action.c **** }
 811:./tmk_core/common/action.c **** 
 812:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 813:./tmk_core/common/action.c **** {
 1828               		.loc 1 813 0
 1829               		.cfi_startproc
 1830               	.LVL228:
 1831               	/* prologue: function */
 1832               	/* frame size = 0 */
 1833               	/* stack size = 0 */
 1834               	.L__stack_usage = 0
 814:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1835               		.loc 1 814 0
 1836 0000 0E94 0000 		call layer_switch_get_action
 1837               	.LVL229:
 815:./tmk_core/common/action.c **** 
 816:./tmk_core/common/action.c ****     switch (action.kind.id) {
 1838               		.loc 1 816 0
 1839 0004 E92F      		mov r30,r25
 1840 0006 E295      		swap r30
 1841 0008 EF70      		andi r30,lo8(15)
 1842 000a E250      		subi r30,lo8(-(-2))
 1843 000c EE30      		cpi r30,lo8(14)
 1844 000e 00F4      		brsh .L214
 1845 0010 F0E0      		ldi r31,0
 1846 0012 E050      		subi r30,lo8(-(gs(.L208)))
 1847 0014 F040      		sbci r31,hi8(-(gs(.L208)))
 1848 0016 0C94 0000 		jmp __tablejump2__
 1849               		.p2align	1
 1850               	.L208:
 1851 001a 0000      		.word gs(.L207)
 1852 001c 0000      		.word gs(.L207)
 1853 001e 0000      		.word gs(.L214)
 1854 0020 0000      		.word gs(.L214)
 1855 0022 0000      		.word gs(.L209)
 1856 0024 0000      		.word gs(.L214)
 1857 0026 0000      		.word gs(.L214)
 1858 0028 0000      		.word gs(.L214)
 1859 002a 0000      		.word gs(.L207)
 1860 002c 0000      		.word gs(.L207)
 1861 002e 0000      		.word gs(.L210)
 1862 0030 0000      		.word gs(.L214)
 1863 0032 0000      		.word gs(.L214)
 1864 0034 0000      		.word gs(.L210)
 1865               	.L207:
 817:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 818:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 819:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 820:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 821:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1866               		.loc 1 821 0
 1867 0036 803F      		cpi r24,lo8(-16)
 1868 0038 01F0      		breq .L216
 1869 003a 00F4      		brsh .L212
 1870 003c 803E      		cpi r24,lo8(-32)
 1871 003e 00F4      		brsh .L214
 1872               	.L216:
 822:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 823:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 824:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 825:./tmk_core/common/action.c ****                     return true;
 1873               		.loc 1 825 0
 1874 0040 81E0      		ldi r24,lo8(1)
 1875               	.LVL230:
 1876               	/* epilogue start */
 826:./tmk_core/common/action.c ****             }
 827:./tmk_core/common/action.c ****             return false;
 828:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 829:./tmk_core/common/action.c ****             switch (action.swap.code) {
 830:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 831:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 832:./tmk_core/common/action.c ****                     return true;
 833:./tmk_core/common/action.c ****             }
 834:./tmk_core/common/action.c ****             return false;
 835:./tmk_core/common/action.c ****         case ACT_MACRO:
 836:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 837:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 838:./tmk_core/common/action.c ****             return false;
 839:./tmk_core/common/action.c ****     }
 840:./tmk_core/common/action.c ****     return false;
 841:./tmk_core/common/action.c **** }
 1877               		.loc 1 841 0
 1878 0042 0895      		ret
 1879               	.LVL231:
 1880               	.L212:
 821:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1881               		.loc 1 821 0
 1882 0044 843F      		cpi r24,lo8(-12)
 1883 0046 01F0      		breq .L216
 1884               	.L214:
 827:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1885               		.loc 1 827 0
 1886 0048 80E0      		ldi r24,0
 1887               	.LVL232:
 1888 004a 0895      		ret
 1889               	.LVL233:
 1890               	.L209:
 829:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1891               		.loc 1 829 0
 1892 004c 803E      		cpi r24,lo8(-32)
 1893 004e 00F0      		brlo .L216
 1894 0050 813F      		cpi r24,lo8(-15)
 1895 0052 01F4      		brne .L214
 1896 0054 00C0      		rjmp .L216
 1897               	.L210:
 837:./tmk_core/common/action.c ****             return false;
 1898               		.loc 1 837 0
 1899 0056 93FB      		bst r25,3
 1900 0058 8827      		clr r24
 1901 005a 80F9      		bld r24,0
 1902               	.LVL234:
 1903 005c 0895      		ret
 1904               		.cfi_endproc
 1905               	.LFE117:
 1907               		.section	.text.debug_event,"ax",@progbits
 1908               	.global	debug_event
 1910               	debug_event:
 1911               	.LFB118:
 842:./tmk_core/common/action.c **** 
 843:./tmk_core/common/action.c **** 
 844:./tmk_core/common/action.c **** /*
 845:./tmk_core/common/action.c ****  * debug print
 846:./tmk_core/common/action.c ****  */
 847:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 848:./tmk_core/common/action.c **** {
 1912               		.loc 1 848 0
 1913               		.cfi_startproc
 1914 0000 CF93      		push r28
 1915               	.LCFI19:
 1916               		.cfi_def_cfa_offset 3
 1917               		.cfi_offset 28, -2
 1918 0002 DF93      		push r29
 1919               	.LCFI20:
 1920               		.cfi_def_cfa_offset 4
 1921               		.cfi_offset 29, -3
 1922 0004 00D0      		rcall .
 1923 0006 00D0      		rcall .
 1924 0008 1F92      		push __zero_reg__
 1925               	.LCFI21:
 1926               		.cfi_def_cfa_offset 9
 1927 000a CDB7      		in r28,__SP_L__
 1928 000c DEB7      		in r29,__SP_H__
 1929               	.LCFI22:
 1930               		.cfi_def_cfa_register 28
 1931               	/* prologue: function */
 1932               	/* frame size = 5 */
 1933               	/* stack size = 7 */
 1934               	.L__stack_usage = 7
 1935               	/* epilogue start */
 849:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 850:./tmk_core/common/action.c **** }
 1936               		.loc 1 850 0
 1937 000e 0F90      		pop __tmp_reg__
 1938 0010 0F90      		pop __tmp_reg__
 1939 0012 0F90      		pop __tmp_reg__
 1940 0014 0F90      		pop __tmp_reg__
 1941 0016 0F90      		pop __tmp_reg__
 1942 0018 DF91      		pop r29
 1943 001a CF91      		pop r28
 1944 001c 0895      		ret
 1945               		.cfi_endproc
 1946               	.LFE118:
 1948               		.section	.text.debug_record,"ax",@progbits
 1949               	.global	debug_record
 1951               	debug_record:
 1952               	.LFB119:
 851:./tmk_core/common/action.c **** 
 852:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 853:./tmk_core/common/action.c **** {
 1953               		.loc 1 853 0
 1954               		.cfi_startproc
 1955 0000 CF93      		push r28
 1956               	.LCFI23:
 1957               		.cfi_def_cfa_offset 3
 1958               		.cfi_offset 28, -2
 1959 0002 DF93      		push r29
 1960               	.LCFI24:
 1961               		.cfi_def_cfa_offset 4
 1962               		.cfi_offset 29, -3
 1963 0004 00D0      		rcall .
 1964 0006 00D0      		rcall .
 1965 0008 00D0      		rcall .
 1966               	.LCFI25:
 1967               		.cfi_def_cfa_offset 10
 1968 000a CDB7      		in r28,__SP_L__
 1969 000c DEB7      		in r29,__SP_H__
 1970               	.LCFI26:
 1971               		.cfi_def_cfa_register 28
 1972               	/* prologue: function */
 1973               	/* frame size = 6 */
 1974               	/* stack size = 8 */
 1975               	.L__stack_usage = 8
 1976               	/* epilogue start */
 854:./tmk_core/common/action.c ****     debug_event(record.event);
 855:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 856:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 857:./tmk_core/common/action.c **** #endif
 858:./tmk_core/common/action.c **** }
 1977               		.loc 1 858 0
 1978 000e 2696      		adiw r28,6
 1979 0010 0FB6      		in __tmp_reg__,__SREG__
 1980 0012 F894      		cli
 1981 0014 DEBF      		out __SP_H__,r29
 1982 0016 0FBE      		out __SREG__,__tmp_reg__
 1983 0018 CDBF      		out __SP_L__,r28
 1984 001a DF91      		pop r29
 1985 001c CF91      		pop r28
 1986 001e 0895      		ret
 1987               		.cfi_endproc
 1988               	.LFE119:
 1990               		.section	.text.debug_action,"ax",@progbits
 1991               	.global	debug_action
 1993               	debug_action:
 1994               	.LFB120:
 859:./tmk_core/common/action.c **** 
 860:./tmk_core/common/action.c **** void debug_action(action_t action)
 861:./tmk_core/common/action.c **** {
 1995               		.loc 1 861 0
 1996               		.cfi_startproc
 1997               	.LVL235:
 1998               	/* prologue: function */
 1999               	/* frame size = 0 */
 2000               	/* stack size = 0 */
 2001               	.L__stack_usage = 0
 2002               	/* epilogue start */
 862:./tmk_core/common/action.c ****     switch (action.kind.id) {
 863:./tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 864:./tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 865:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
 866:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
 867:./tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
 868:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
 869:./tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
 870:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
 871:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
 872:./tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
 873:./tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
 874:./tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
 875:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
 876:./tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
 877:./tmk_core/common/action.c ****     }
 878:./tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 879:./tmk_core/common/action.c **** }
 2003               		.loc 1 879 0
 2004 0000 0895      		ret
 2005               		.cfi_endproc
 2006               	.LFE120:
 2008               	.global	disable_action_cache
 2009               		.section	.bss.disable_action_cache,"aw",@nobits
 2012               	disable_action_cache:
 2013 0000 00        		.zero	1
 2014               		.comm	tp_buttons,2,1
 2015               		.text
 2016               	.Letext0:
 2017               		.file 4 "/usr/avr/include/stdint.h"
 2018               		.file 5 "./tmk_core/common/keycode.h"
 2019               		.file 6 "./lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2020               		.file 7 "./lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2021               		.file 8 "./lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2022               		.file 9 "./lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2023               		.file 10 "/usr/avr/include/stdio.h"
 2024               		.file 11 "./tmk_core/common/report.h"
 2025               		.file 12 "./tmk_core/common/host.h"
 2026               		.file 13 "./tmk_core/common/mousekey.h"
 2027               		.file 14 "./tmk_core/common/command.h"
 2028               		.file 15 "./tmk_core/common/action_code.h"
 2029               		.file 16 "./tmk_core/common/action.h"
 2030               		.file 17 "./tmk_core/common/action_layer.h"
 2031               		.file 18 "./tmk_core/common/action_util.h"
 2032               		.file 19 "./tmk_core/common/debug.h"
 2033               		.file 20 "./tmk_core/common/led.h"
 2034               		.file 21 "./tmk_core/common/action_macro.h"
 2035               		.file 22 "./tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/cc5rxjaV.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc5rxjaV.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc5rxjaV.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc5rxjaV.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc5rxjaV.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc5rxjaV.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/cc5rxjaV.s:89     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cc5rxjaV.s:109    .text.register_code:0000000000000000 register_code
     /tmp/cc5rxjaV.s:533    .text.unregister_code:0000000000000000 unregister_code
     /tmp/cc5rxjaV.s:671    .text.register_mods:0000000000000000 register_mods
     /tmp/cc5rxjaV.s:699    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/cc5rxjaV.s:727    .text.process_action:0000000000000000 process_action
     /tmp/cc5rxjaV.s:1646   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
     /tmp/cc5rxjaV.s:1748   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/cc5rxjaV.s:2012   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/cc5rxjaV.s:1774   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/cc5rxjaV.s:1806   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/cc5rxjaV.s:1826   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/cc5rxjaV.s:1910   .text.debug_event:0000000000000000 debug_event
     /tmp/cc5rxjaV.s:1951   .text.debug_record:0000000000000000 debug_record
     /tmp/cc5rxjaV.s:1993   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
host_keyboard_leds
add_key
send_keyboard_report
del_key
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_send
mousekey_off
default_layer_and
led_set
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
mousekey_clear
clear_mods
layer_switch_get_action
__do_clear_bss
