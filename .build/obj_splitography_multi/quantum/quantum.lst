   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB110:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #include "backlight.h"
  27:quantum/quantum.c **** extern backlight_config_t backlight_config;
  28:quantum/quantum.c **** 
  29:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  30:quantum/quantum.c **** #include "fauxclicky.h"
  31:quantum/quantum.c **** #endif
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  34:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  35:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  36:quantum/quantum.c ****   #endif
  37:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  38:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  39:quantum/quantum.c ****   #endif
  40:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  41:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  42:quantum/quantum.c ****   #endif
  43:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  44:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  45:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  46:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  47:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c **** #endif
  50:quantum/quantum.c **** 
  51:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 51 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  52:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 52 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  53:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  54:quantum/quantum.c ****     break;
  55:quantum/quantum.c ****   default:
  56:quantum/quantum.c ****     return;
  57:quantum/quantum.c ****   }
  58:quantum/quantum.c **** 
  59:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 59 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  60:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 60 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  61:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 61 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  62:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 62 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  63:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 63 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  64:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 64 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  65:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 65 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  66:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 66 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  67:quantum/quantum.c **** 
  68:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 68 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F4      		brsh .L21
  86               	.L1:
  87               	/* epilogue start */
  69:quantum/quantum.c **** 
  70:quantum/quantum.c ****   if (code & QK_RCTL)
  71:quantum/quantum.c ****     f(KC_RCTL);
  72:quantum/quantum.c ****   if (code & QK_RSFT)
  73:quantum/quantum.c ****     f(KC_RSFT);
  74:quantum/quantum.c ****   if (code & QK_RALT)
  75:quantum/quantum.c ****     f(KC_RALT);
  76:quantum/quantum.c ****   if (code & QK_RGUI)
  77:quantum/quantum.c ****     f(KC_RGUI);
  78:quantum/quantum.c **** }
  88               		.loc 1 78 0
  89 0042 DF91      		pop r29
  90 0044 CF91      		pop r28
  91               	.LVL6:
  92 0046 1F91      		pop r17
  93 0048 0F91      		pop r16
  94               	.LVL7:
  95 004a 0895      		ret
  96               	.LVL8:
  97               	.L21:
  71:quantum/quantum.c ****   if (code & QK_RSFT)
  98               		.loc 1 71 0
  99 004c 84EE      		ldi r24,lo8(-28)
 100 004e FE01      		movw r30,r28
 101 0050 0995      		icall
 102               	.LVL9:
  73:quantum/quantum.c ****   if (code & QK_RALT)
 103               		.loc 1 73 0
 104 0052 85EE      		ldi r24,lo8(-27)
 105 0054 FE01      		movw r30,r28
 106 0056 0995      		icall
 107               	.LVL10:
  75:quantum/quantum.c ****   if (code & QK_RGUI)
 108               		.loc 1 75 0
 109 0058 86EE      		ldi r24,lo8(-26)
 110 005a FE01      		movw r30,r28
 111 005c 0995      		icall
 112               	.LVL11:
  77:quantum/quantum.c **** }
 113               		.loc 1 77 0
 114 005e 87EE      		ldi r24,lo8(-25)
 115 0060 FE01      		movw r30,r28
 116               	/* epilogue start */
 117               		.loc 1 78 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
  77:quantum/quantum.c **** }
 124               		.loc 1 77 0
 125 006a 0994      		ijmp
 126               	.LVL14:
 127               		.cfi_endproc
 128               	.LFE110:
 130               		.section	.text.qk_register_weak_mods,"ax",@progbits
 132               	qk_register_weak_mods:
 133               	.LFB111:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 134               		.loc 1 80 0
 135               		.cfi_startproc
 136               	.LVL15:
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
  81:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 141               		.loc 1 81 0
 142 0000 8770      		andi r24,lo8(7)
 143               	.LVL16:
 144 0002 91E0      		ldi r25,lo8(1)
 145 0004 00C0      		rjmp 2f
 146               		1:
 147 0006 990F      		lsl r25
 148               		2:
 149 0008 8A95      		dec r24
 150 000a 02F4      		brpl 1b
 151 000c 892F      		mov r24,r25
 152 000e 0E94 0000 		call add_weak_mods
 153               	.LVL17:
  82:quantum/quantum.c ****     send_keyboard_report();
 154               		.loc 1 82 0
 155 0012 0C94 0000 		jmp send_keyboard_report
 156               	.LVL18:
 157               		.cfi_endproc
 158               	.LFE111:
 160               		.section	.text.qk_register_mods,"ax",@progbits
 162               	qk_register_mods:
 163               	.LFB155:
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169 0000 0C94 0000 		jmp qk_register_weak_mods
 170               		.cfi_endproc
 171               	.LFE155:
 173               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 175               	qk_unregister_weak_mods:
 176               	.LFB112:
  83:quantum/quantum.c **** }
  84:quantum/quantum.c **** 
  85:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 177               		.loc 1 85 0
 178               		.cfi_startproc
 179               	.LVL19:
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
  86:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 184               		.loc 1 86 0
 185 0000 8770      		andi r24,lo8(7)
 186               	.LVL20:
 187 0002 91E0      		ldi r25,lo8(1)
 188 0004 00C0      		rjmp 2f
 189               		1:
 190 0006 990F      		lsl r25
 191               		2:
 192 0008 8A95      		dec r24
 193 000a 02F4      		brpl 1b
 194 000c 892F      		mov r24,r25
 195 000e 0E94 0000 		call del_weak_mods
 196               	.LVL21:
  87:quantum/quantum.c ****     send_keyboard_report();
 197               		.loc 1 87 0
 198 0012 0C94 0000 		jmp send_keyboard_report
 199               	.LVL22:
 200               		.cfi_endproc
 201               	.LFE112:
 203               		.section	.text.qk_unregister_mods,"ax",@progbits
 205               	qk_unregister_mods:
 206               	.LFB157:
 207               		.cfi_startproc
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 0 */
 211               	.L__stack_usage = 0
 212 0000 0C94 0000 		jmp qk_unregister_weak_mods
 213               		.cfi_endproc
 214               	.LFE157:
 216               		.section	.text.register_code16,"ax",@progbits
 217               	.global	register_code16
 219               	register_code16:
 220               	.LFB115:
  88:quantum/quantum.c **** }
  89:quantum/quantum.c **** 
  90:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
  91:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
  92:quantum/quantum.c ****     send_keyboard_report();
  93:quantum/quantum.c **** }
  94:quantum/quantum.c **** 
  95:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
  96:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  97:quantum/quantum.c ****     send_keyboard_report();
  98:quantum/quantum.c **** }
  99:quantum/quantum.c **** 
 100:quantum/quantum.c **** void register_code16 (uint16_t code) {
 221               		.loc 1 100 0
 222               		.cfi_startproc
 223               	.LVL23:
 224               		.loc 1 100 0
 225 0000 CF93      		push r28
 226               	.LCFI4:
 227               		.cfi_def_cfa_offset 3
 228               		.cfi_offset 28, -2
 229 0002 DF93      		push r29
 230               	.LCFI5:
 231               		.cfi_def_cfa_offset 4
 232               		.cfi_offset 29, -3
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 2 */
 236               	.L__stack_usage = 2
 237 0004 EC01      		movw r28,r24
 101:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 238               		.loc 1 101 0
 239 0006 805E      		subi r24,-32
 240 0008 9109      		sbc r25,__zero_reg__
 241               	.LVL24:
 242 000a 0897      		sbiw r24,8
 243 000c 00F0      		brlo .L27
 102:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 103:quantum/quantum.c ****   } else {
 104:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 244               		.loc 1 104 0 discriminator 1
 245 000e 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 246 0010 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 101:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 247               		.loc 1 101 0 discriminator 1
 248 0012 2097      		sbiw r28,0
 249 0014 01F4      		brne .L30
 250               	.L27:
 102:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 251               		.loc 1 102 0
 252 0016 60E0      		ldi r22,lo8(gs(qk_register_mods))
 253 0018 70E0      		ldi r23,hi8(gs(qk_register_mods))
 254               	.L30:
 255               		.loc 1 104 0
 256 001a CE01      		movw r24,r28
 257 001c 0E94 0000 		call do_code16
 258               	.LVL25:
 105:quantum/quantum.c ****   }
 106:quantum/quantum.c ****   register_code (code);
 259               		.loc 1 106 0
 260 0020 8C2F      		mov r24,r28
 261               	/* epilogue start */
 107:quantum/quantum.c **** }
 262               		.loc 1 107 0
 263 0022 DF91      		pop r29
 264 0024 CF91      		pop r28
 265               	.LVL26:
 106:quantum/quantum.c **** }
 266               		.loc 1 106 0
 267 0026 0C94 0000 		jmp register_code
 268               	.LVL27:
 269               		.cfi_endproc
 270               	.LFE115:
 272               		.section	.text.unregister_code16,"ax",@progbits
 273               	.global	unregister_code16
 275               	unregister_code16:
 276               	.LFB116:
 108:quantum/quantum.c **** 
 109:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 277               		.loc 1 109 0
 278               		.cfi_startproc
 279               	.LVL28:
 280 0000 CF93      		push r28
 281               	.LCFI6:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 0002 DF93      		push r29
 285               	.LCFI7:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288               	/* prologue: function */
 289               	/* frame size = 0 */
 290               	/* stack size = 2 */
 291               	.L__stack_usage = 2
 292 0004 EC01      		movw r28,r24
 110:quantum/quantum.c ****   unregister_code (code);
 293               		.loc 1 110 0
 294 0006 0E94 0000 		call unregister_code
 295               	.LVL29:
 111:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 296               		.loc 1 111 0
 297 000a CE01      		movw r24,r28
 298 000c 805E      		subi r24,-32
 299 000e 9109      		sbc r25,__zero_reg__
 300 0010 0897      		sbiw r24,8
 301 0012 00F0      		brlo .L32
 112:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 113:quantum/quantum.c ****   } else {
 114:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 302               		.loc 1 114 0 discriminator 1
 303 0014 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 304 0016 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 111:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 305               		.loc 1 111 0 discriminator 1
 306 0018 2097      		sbiw r28,0
 307 001a 01F4      		brne .L34
 308               	.L32:
 112:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 309               		.loc 1 112 0
 310 001c 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 311 001e 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 312               	.L34:
 313               		.loc 1 114 0
 314 0020 CE01      		movw r24,r28
 315               	/* epilogue start */
 115:quantum/quantum.c ****   }
 116:quantum/quantum.c **** }
 316               		.loc 1 116 0
 317 0022 DF91      		pop r29
 318 0024 CF91      		pop r28
 319               	.LVL30:
 114:quantum/quantum.c ****   }
 320               		.loc 1 114 0
 321 0026 0C94 0000 		jmp do_code16
 322               	.LVL31:
 323               		.cfi_endproc
 324               	.LFE116:
 326               		.section	.text.process_action_kb,"ax",@progbits
 327               		.weak	process_action_kb
 329               	process_action_kb:
 330               	.LFB117:
 117:quantum/quantum.c **** 
 118:quantum/quantum.c **** __attribute__ ((weak))
 119:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 331               		.loc 1 119 0
 332               		.cfi_startproc
 333               	.LVL32:
 334               	/* prologue: function */
 335               	/* frame size = 0 */
 336               	/* stack size = 0 */
 337               	.L__stack_usage = 0
 120:quantum/quantum.c ****   return true;
 121:quantum/quantum.c **** }
 338               		.loc 1 121 0
 339 0000 81E0      		ldi r24,lo8(1)
 340               	.LVL33:
 341               	/* epilogue start */
 342 0002 0895      		ret
 343               		.cfi_endproc
 344               	.LFE117:
 346               		.section	.text.process_record_user,"ax",@progbits
 347               		.weak	process_record_user
 349               	process_record_user:
 350               	.LFB119:
 122:quantum/quantum.c **** 
 123:quantum/quantum.c **** __attribute__ ((weak))
 124:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 125:quantum/quantum.c ****   return process_record_user(keycode, record);
 126:quantum/quantum.c **** }
 127:quantum/quantum.c **** 
 128:quantum/quantum.c **** __attribute__ ((weak))
 129:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 351               		.loc 1 129 0
 352               		.cfi_startproc
 353               	.LVL34:
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 0 */
 357               	.L__stack_usage = 0
 130:quantum/quantum.c ****   return true;
 131:quantum/quantum.c **** }
 358               		.loc 1 131 0
 359 0000 81E0      		ldi r24,lo8(1)
 360               	.LVL35:
 361               	/* epilogue start */
 362 0002 0895      		ret
 363               		.cfi_endproc
 364               	.LFE119:
 366               		.section	.text.process_record_kb,"ax",@progbits
 367               		.weak	process_record_kb
 369               	process_record_kb:
 370               	.LFB118:
 124:quantum/quantum.c ****   return process_record_user(keycode, record);
 371               		.loc 1 124 0
 372               		.cfi_startproc
 373               	.LVL36:
 374               	/* prologue: function */
 375               	/* frame size = 0 */
 376               	/* stack size = 0 */
 377               	.L__stack_usage = 0
 125:quantum/quantum.c **** }
 378               		.loc 1 125 0
 379 0000 0C94 0000 		jmp process_record_user
 380               	.LVL37:
 381               		.cfi_endproc
 382               	.LFE118:
 384               		.section	.text.reset_keyboard,"ax",@progbits
 385               	.global	reset_keyboard
 387               	reset_keyboard:
 388               	.LFB120:
 132:quantum/quantum.c **** 
 133:quantum/quantum.c **** void reset_keyboard(void) {
 389               		.loc 1 133 0
 390               		.cfi_startproc
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 134:quantum/quantum.c ****   clear_keyboard();
 395               		.loc 1 134 0
 396 0000 0E94 0000 		call clear_keyboard
 397               	.LVL38:
 398               	.LBB22:
 399               	.LBB23:
 400               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 401               		.loc 2 187 0
 402 0004 2FEF      		ldi r18,lo8(799999)
 403 0006 84E3      		ldi r24,hi8(799999)
 404 0008 9CE0      		ldi r25,hlo8(799999)
 405 000a 2150      	1:	subi r18,1
 406 000c 8040      		sbci r24,0
 407 000e 9040      		sbci r25,0
 408 0010 01F4      		brne 1b
 409 0012 00C0      		rjmp .
 410 0014 0000      		nop
 411               	.LVL39:
 412               	.LBE23:
 413               	.LBE22:
 135:quantum/quantum.c **** #if defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_ENABLE_BASIC))
 136:quantum/quantum.c ****   music_all_notes_off();
 137:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 138:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 139:quantum/quantum.c ****   shutdown_user();
 140:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250) 
 141:quantum/quantum.c ****     wait_ms(1);
 142:quantum/quantum.c ****   stop_all_notes();
 143:quantum/quantum.c **** #else
 144:quantum/quantum.c ****   wait_ms(250);
 145:quantum/quantum.c **** #endif
 146:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 147:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 148:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c ****   bootloader_jump();
 414               		.loc 1 150 0
 415 0016 0C94 0000 		jmp bootloader_jump
 416               	.LVL40:
 417               		.cfi_endproc
 418               	.LFE120:
 420               		.section	.text.process_record_quantum,"ax",@progbits
 421               	.global	process_record_quantum
 423               	process_record_quantum:
 424               	.LFB121:
 151:quantum/quantum.c **** }
 152:quantum/quantum.c **** 
 153:quantum/quantum.c **** // Shift / paren setup
 154:quantum/quantum.c **** 
 155:quantum/quantum.c **** #ifndef LSPO_KEY
 156:quantum/quantum.c ****   #define LSPO_KEY KC_9
 157:quantum/quantum.c **** #endif
 158:quantum/quantum.c **** #ifndef RSPC_KEY
 159:quantum/quantum.c ****   #define RSPC_KEY KC_0
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** 
 162:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 163:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 164:quantum/quantum.c **** 
 165:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 166:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 167:quantum/quantum.c ****  */
 168:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 425               		.loc 1 170 0
 426               		.cfi_startproc
 427               	.LVL41:
 428 0000 FF92      		push r15
 429               	.LCFI8:
 430               		.cfi_def_cfa_offset 3
 431               		.cfi_offset 15, -2
 432 0002 0F93      		push r16
 433               	.LCFI9:
 434               		.cfi_def_cfa_offset 4
 435               		.cfi_offset 16, -3
 436 0004 1F93      		push r17
 437               	.LCFI10:
 438               		.cfi_def_cfa_offset 5
 439               		.cfi_offset 17, -4
 440 0006 CF93      		push r28
 441               	.LCFI11:
 442               		.cfi_def_cfa_offset 6
 443               		.cfi_offset 28, -5
 444 0008 DF93      		push r29
 445               	.LCFI12:
 446               		.cfi_def_cfa_offset 7
 447               		.cfi_offset 29, -6
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 5 */
 451               	.L__stack_usage = 5
 452 000a 8C01      		movw r16,r24
 171:quantum/quantum.c **** 
 172:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 173:quantum/quantum.c ****   keypos_t key = record->event.key;
 453               		.loc 1 173 0
 454 000c FC01      		movw r30,r24
 455 000e C081      		ld r28,Z
 456 0010 D181      		ldd r29,Z+1
 457               	.LVL42:
 174:quantum/quantum.c ****   uint16_t keycode;
 175:quantum/quantum.c **** 
 176:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 177:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 178:quantum/quantum.c ****     if (!disable_action_cache) {
 458               		.loc 1 178 0
 459 0012 8091 0000 		lds r24,disable_action_cache
 460               	.LVL43:
 461 0016 8111      		cpse r24,__zero_reg__
 462 0018 00C0      		rjmp .L40
 463               	.LBB24:
 179:quantum/quantum.c ****       uint8_t layer;
 180:quantum/quantum.c **** 
 181:quantum/quantum.c ****       if (record->event.pressed) {
 464               		.loc 1 181 0
 465 001a 8281      		ldd r24,Z+2
 466 001c 8823      		tst r24
 467 001e 01F0      		breq .L41
 468               	.LVL44:
 182:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 469               		.loc 1 182 0
 470 0020 CE01      		movw r24,r28
 471 0022 0E94 0000 		call layer_switch_get_layer
 472               	.LVL45:
 473 0026 F82E      		mov r15,r24
 474               	.LVL46:
 183:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 475               		.loc 1 183 0
 476 0028 682F      		mov r22,r24
 477 002a CE01      		movw r24,r28
 478 002c 0E94 0000 		call update_source_layers_cache
 479               	.LVL47:
 480               	.L42:
 184:quantum/quantum.c ****       } else {
 185:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 186:quantum/quantum.c ****       }
 187:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 481               		.loc 1 187 0
 482 0030 BE01      		movw r22,r28
 483 0032 8F2D      		mov r24,r15
 484               	.LVL48:
 485               	.L117:
 486               	.LBE24:
 188:quantum/quantum.c ****     } else
 189:quantum/quantum.c ****   #endif
 190:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 487               		.loc 1 190 0
 488 0034 0E94 0000 		call keymap_key_to_keycode
 489               	.LVL49:
 490 0038 EC01      		movw r28,r24
 491               	.LVL50:
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****     // This is how you use actions here
 193:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 194:quantum/quantum.c ****     //   action_t action;
 195:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 196:quantum/quantum.c ****     //   process_action(record, action);
 197:quantum/quantum.c ****     //   return false;
 198:quantum/quantum.c ****     // }
 199:quantum/quantum.c **** 
 200:quantum/quantum.c ****   if (!(
 201:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 202:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 203:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 204:quantum/quantum.c ****   #endif
 205:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 492               		.loc 1 205 0
 493 003a B801      		movw r22,r16
 494 003c 0E94 0000 		call process_record_kb
 495               	.LVL51:
 206:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 207:quantum/quantum.c ****     process_midi(keycode, record) &&
 208:quantum/quantum.c ****   #endif
 209:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 210:quantum/quantum.c ****     process_audio(keycode, record) &&
 211:quantum/quantum.c ****   #endif
 212:quantum/quantum.c ****   #ifdef STENO_ENABLE
 213:quantum/quantum.c ****     process_steno(keycode, record) &&
 496               		.loc 1 213 0
 497 0040 8823      		tst r24
 498 0042 01F4      		brne .+2
 499 0044 00C0      		rjmp .L39
 500               		.loc 1 213 0 is_stmt 0 discriminator 2
 501 0046 B801      		movw r22,r16
 502 0048 CE01      		movw r24,r28
 503 004a 0E94 0000 		call process_steno
 504               	.LVL52:
 205:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 505               		.loc 1 205 0 is_stmt 1 discriminator 2
 506 004e 8823      		tst r24
 507 0050 01F4      		brne .+2
 508 0052 00C0      		rjmp .L39
 214:quantum/quantum.c ****   #endif
 215:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))
 216:quantum/quantum.c ****     process_music(keycode, record) &&
 217:quantum/quantum.c ****   #endif
 218:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 219:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 220:quantum/quantum.c ****   #endif
 221:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 222:quantum/quantum.c ****     process_leader(keycode, record) &&
 509               		.loc 1 222 0 discriminator 3
 510 0054 B801      		movw r22,r16
 511 0056 CE01      		movw r24,r28
 512 0058 0E94 0000 		call process_leader
 513               	.LVL53:
 213:quantum/quantum.c ****   #endif
 514               		.loc 1 213 0 discriminator 3
 515 005c 8823      		tst r24
 516 005e 01F4      		brne .+2
 517 0060 00C0      		rjmp .L39
 223:quantum/quantum.c ****   #endif
 224:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 225:quantum/quantum.c ****     process_chording(keycode, record) &&
 226:quantum/quantum.c ****   #endif
 227:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 228:quantum/quantum.c ****     process_combo(keycode, record) &&
 229:quantum/quantum.c ****   #endif
 230:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 231:quantum/quantum.c ****     process_unicode(keycode, record) &&
 232:quantum/quantum.c ****   #endif
 233:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 234:quantum/quantum.c ****     process_ucis(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 237:quantum/quantum.c ****     process_printer(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 240:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 243:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 246:quantum/quantum.c ****     process_terminal(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****       true)) {
 249:quantum/quantum.c ****     return false;
 250:quantum/quantum.c ****   }
 251:quantum/quantum.c **** 
 252:quantum/quantum.c ****   // Shift / paren setup
 253:quantum/quantum.c **** 
 254:quantum/quantum.c ****   switch(keycode) {
 518               		.loc 1 254 0
 519 0062 C531      		cpi r28,21
 520 0064 FCE5      		ldi r31,92
 521 0066 DF07      		cpc r29,r31
 522 0068 01F4      		brne .+2
 523 006a 00C0      		rjmp .L48
 524 006c 00F4      		brsh .L49
 525 006e C130      		cpi r28,1
 526 0070 ECE5      		ldi r30,92
 527 0072 DE07      		cpc r29,r30
 528 0074 01F4      		brne .+2
 529 0076 00C0      		rjmp .L50
 530 0078 00F0      		brlo .+2
 531 007a 00C0      		rjmp .L51
 532 007c C115      		cp r28,__zero_reg__
 533 007e DC45      		sbci r29,92
 534 0080 01F0      		breq .L52
 535               	.L47:
 255:quantum/quantum.c ****     case RESET:
 256:quantum/quantum.c ****       if (record->event.pressed) {
 257:quantum/quantum.c ****         reset_keyboard();
 258:quantum/quantum.c ****       }
 259:quantum/quantum.c ****     return false;
 260:quantum/quantum.c ****     case DEBUG:
 261:quantum/quantum.c ****       if (record->event.pressed) {
 262:quantum/quantum.c ****           debug_enable = true;
 263:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 264:quantum/quantum.c ****       }
 265:quantum/quantum.c ****     return false;
 266:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 267:quantum/quantum.c ****   case FC_TOG:
 268:quantum/quantum.c ****     if (record->event.pressed) {
 269:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 270:quantum/quantum.c ****     }
 271:quantum/quantum.c ****     return false;
 272:quantum/quantum.c ****   case FC_ON:
 273:quantum/quantum.c ****     if (record->event.pressed) {
 274:quantum/quantum.c ****       FAUXCLICKY_ON;
 275:quantum/quantum.c ****     }
 276:quantum/quantum.c ****     return false;
 277:quantum/quantum.c ****   case FC_OFF:
 278:quantum/quantum.c ****     if (record->event.pressed) {
 279:quantum/quantum.c ****       FAUXCLICKY_OFF;
 280:quantum/quantum.c ****     }
 281:quantum/quantum.c ****     return false;
 282:quantum/quantum.c ****   #endif
 283:quantum/quantum.c ****   #ifdef RGBLIGHT_ENABLE
 284:quantum/quantum.c ****   case RGB_TOG:
 285:quantum/quantum.c ****     if (record->event.pressed) {
 286:quantum/quantum.c ****       rgblight_toggle();
 287:quantum/quantum.c ****     }
 288:quantum/quantum.c ****     return false;
 289:quantum/quantum.c ****   case RGB_MOD:
 290:quantum/quantum.c ****     if (record->event.pressed) {
 291:quantum/quantum.c ****       rgblight_step();
 292:quantum/quantum.c ****     }
 293:quantum/quantum.c ****     return false;
 294:quantum/quantum.c ****   case RGB_SMOD:
 295:quantum/quantum.c ****     // same as RBG_MOD, but if shift is pressed, it will use the reverese direction instead.
 296:quantum/quantum.c ****     if (record->event.pressed) {
 297:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 298:quantum/quantum.c ****       if(shifted) {
 299:quantum/quantum.c ****         rgblight_step_reverse();
 300:quantum/quantum.c ****       }
 301:quantum/quantum.c ****       else {
 302:quantum/quantum.c ****         rgblight_step();
 303:quantum/quantum.c ****       }
 304:quantum/quantum.c ****     }
 305:quantum/quantum.c ****     return false;
 306:quantum/quantum.c ****   case RGB_HUI:
 307:quantum/quantum.c ****     if (record->event.pressed) {
 308:quantum/quantum.c ****       rgblight_increase_hue();
 309:quantum/quantum.c ****     }
 310:quantum/quantum.c ****     return false;
 311:quantum/quantum.c ****   case RGB_HUD:
 312:quantum/quantum.c ****     if (record->event.pressed) {
 313:quantum/quantum.c ****       rgblight_decrease_hue();
 314:quantum/quantum.c ****     }
 315:quantum/quantum.c ****     return false;
 316:quantum/quantum.c ****   case RGB_SAI:
 317:quantum/quantum.c ****     if (record->event.pressed) {
 318:quantum/quantum.c ****       rgblight_increase_sat();
 319:quantum/quantum.c ****     }
 320:quantum/quantum.c ****     return false;
 321:quantum/quantum.c ****   case RGB_SAD:
 322:quantum/quantum.c ****     if (record->event.pressed) {
 323:quantum/quantum.c ****       rgblight_decrease_sat();
 324:quantum/quantum.c ****     }
 325:quantum/quantum.c ****     return false;
 326:quantum/quantum.c ****   case RGB_VAI:
 327:quantum/quantum.c ****     if (record->event.pressed) {
 328:quantum/quantum.c ****       rgblight_increase_val();
 329:quantum/quantum.c ****     }
 330:quantum/quantum.c ****     return false;
 331:quantum/quantum.c ****   case RGB_VAD:
 332:quantum/quantum.c ****     if (record->event.pressed) {
 333:quantum/quantum.c ****       rgblight_decrease_val();
 334:quantum/quantum.c ****     }
 335:quantum/quantum.c ****     return false;
 336:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 337:quantum/quantum.c ****     if (record->event.pressed) {
 338:quantum/quantum.c ****       rgblight_mode(1);
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 344:quantum/quantum.c ****         rgblight_step();
 345:quantum/quantum.c ****       } else {
 346:quantum/quantum.c ****         rgblight_mode(2);
 347:quantum/quantum.c ****       }
 348:quantum/quantum.c ****     }
 349:quantum/quantum.c ****     return false;
 350:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 351:quantum/quantum.c ****     if (record->event.pressed) {
 352:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 353:quantum/quantum.c ****         rgblight_step();
 354:quantum/quantum.c ****       } else {
 355:quantum/quantum.c ****         rgblight_mode(6);
 356:quantum/quantum.c ****       }
 357:quantum/quantum.c ****     }
 358:quantum/quantum.c ****     return false;
 359:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 360:quantum/quantum.c ****     if (record->event.pressed) {
 361:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 362:quantum/quantum.c ****         rgblight_step();
 363:quantum/quantum.c ****       } else {
 364:quantum/quantum.c ****         rgblight_mode(9);
 365:quantum/quantum.c ****       }
 366:quantum/quantum.c ****     }
 367:quantum/quantum.c ****     return false;
 368:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 369:quantum/quantum.c ****     if (record->event.pressed) {
 370:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 371:quantum/quantum.c ****         rgblight_step();
 372:quantum/quantum.c ****       } else {
 373:quantum/quantum.c ****         rgblight_mode(15);
 374:quantum/quantum.c ****       }
 375:quantum/quantum.c ****     }
 376:quantum/quantum.c ****     return false;
 377:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 378:quantum/quantum.c ****     if (record->event.pressed) {
 379:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 380:quantum/quantum.c ****         rgblight_step();
 381:quantum/quantum.c ****       } else {
 382:quantum/quantum.c ****         rgblight_mode(21);
 383:quantum/quantum.c ****       }
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_XMAS:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       rgblight_mode(24);
 389:quantum/quantum.c ****     }
 390:quantum/quantum.c ****     return false;
 391:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 392:quantum/quantum.c ****     if (record->event.pressed) {
 393:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 394:quantum/quantum.c ****         rgblight_step();
 395:quantum/quantum.c ****       } else {
 396:quantum/quantum.c ****         rgblight_mode(25);
 397:quantum/quantum.c ****       }
 398:quantum/quantum.c ****     }
 399:quantum/quantum.c ****     return false;
 400:quantum/quantum.c ****   #endif
 401:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 402:quantum/quantum.c ****     case OUT_AUTO:
 403:quantum/quantum.c ****       if (record->event.pressed) {
 404:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 405:quantum/quantum.c ****       }
 406:quantum/quantum.c ****       return false;
 407:quantum/quantum.c ****     case OUT_USB:
 408:quantum/quantum.c ****       if (record->event.pressed) {
 409:quantum/quantum.c ****         set_output(OUTPUT_USB);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****       return false;
 412:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 413:quantum/quantum.c ****     case OUT_BT:
 414:quantum/quantum.c ****       if (record->event.pressed) {
 415:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 416:quantum/quantum.c ****       }
 417:quantum/quantum.c ****       return false;
 418:quantum/quantum.c ****     #endif
 419:quantum/quantum.c ****     #endif
 420:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 421:quantum/quantum.c ****       if (record->event.pressed) {
 422:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 423:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 424:quantum/quantum.c ****             eeconfig_init();
 425:quantum/quantum.c ****         }
 426:quantum/quantum.c ****         /* keymap config */
 427:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 428:quantum/quantum.c ****         switch (keycode)
 429:quantum/quantum.c ****         {
 430:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 431:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 432:quantum/quantum.c ****             break;
 433:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 434:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 435:quantum/quantum.c ****             break;
 436:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 437:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 438:quantum/quantum.c ****             break;
 439:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 440:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 441:quantum/quantum.c ****             break;
 442:quantum/quantum.c ****           case MAGIC_NO_GUI:
 443:quantum/quantum.c ****             keymap_config.no_gui = true;
 444:quantum/quantum.c ****             break;
 445:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 446:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 447:quantum/quantum.c ****             break;
 448:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 449:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 450:quantum/quantum.c ****             break;
 451:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 452:quantum/quantum.c ****             keymap_config.nkro = true;
 453:quantum/quantum.c ****             break;
 454:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 455:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 456:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 457:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 458:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 459:quantum/quantum.c ****             #endif
 460:quantum/quantum.c ****             break;
 461:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 462:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 463:quantum/quantum.c ****             break;
 464:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 465:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 466:quantum/quantum.c ****             break;
 467:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 468:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 469:quantum/quantum.c ****             break;
 470:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 471:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 472:quantum/quantum.c ****             break;
 473:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 474:quantum/quantum.c ****             keymap_config.no_gui = false;
 475:quantum/quantum.c ****             break;
 476:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 477:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 478:quantum/quantum.c ****             break;
 479:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 480:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 481:quantum/quantum.c ****             break;
 482:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 483:quantum/quantum.c ****             keymap_config.nkro = false;
 484:quantum/quantum.c ****             break;
 485:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 486:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 487:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 488:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 489:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 490:quantum/quantum.c ****             #endif
 491:quantum/quantum.c ****             break;
 492:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 493:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 494:quantum/quantum.c ****             break;
 495:quantum/quantum.c ****           default:
 496:quantum/quantum.c ****             break;
 497:quantum/quantum.c ****         }
 498:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 499:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 500:quantum/quantum.c **** 
 501:quantum/quantum.c ****         return false;
 502:quantum/quantum.c ****       }
 503:quantum/quantum.c ****       break;
 504:quantum/quantum.c ****     case KC_LSPO: {
 505:quantum/quantum.c ****       if (record->event.pressed) {
 506:quantum/quantum.c ****         shift_interrupted[0] = false;
 507:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 508:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 509:quantum/quantum.c ****       }
 510:quantum/quantum.c ****       else {
 511:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 512:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 513:quantum/quantum.c ****             shift_interrupted[0] = true;
 514:quantum/quantum.c ****             shift_interrupted[1] = true;
 515:quantum/quantum.c ****           }
 516:quantum/quantum.c ****         #endif
 517:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 518:quantum/quantum.c ****           register_code(LSPO_KEY);
 519:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 520:quantum/quantum.c ****         }
 521:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 522:quantum/quantum.c ****       }
 523:quantum/quantum.c ****       return false;
 524:quantum/quantum.c ****     }
 525:quantum/quantum.c **** 
 526:quantum/quantum.c ****     case KC_RSPC: {
 527:quantum/quantum.c ****       if (record->event.pressed) {
 528:quantum/quantum.c ****         shift_interrupted[1] = false;
 529:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 530:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 531:quantum/quantum.c ****       }
 532:quantum/quantum.c ****       else {
 533:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 534:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 535:quantum/quantum.c ****             shift_interrupted[0] = true;
 536:quantum/quantum.c ****             shift_interrupted[1] = true;
 537:quantum/quantum.c ****           }
 538:quantum/quantum.c ****         #endif
 539:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 540:quantum/quantum.c ****           register_code(RSPC_KEY);
 541:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 544:quantum/quantum.c ****       }
 545:quantum/quantum.c ****       return false;
 546:quantum/quantum.c ****     }
 547:quantum/quantum.c ****     case GRAVE_ESC: {
 548:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 549:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 550:quantum/quantum.c **** 
 551:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 552:quantum/quantum.c ****       // if CTRL is pressed, ESC is always read as ESC, even if SHIFT or GUI is pressed.
 553:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 554:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL)))
 555:quantum/quantum.c ****         shifted = 0;
 556:quantum/quantum.c **** #endif
 557:quantum/quantum.c **** 
 558:quantum/quantum.c ****       if (record->event.pressed) {
 559:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 560:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 561:quantum/quantum.c ****       }
 562:quantum/quantum.c ****       else {
 563:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 564:quantum/quantum.c ****       }
 565:quantum/quantum.c **** 
 566:quantum/quantum.c ****       send_keyboard_report();
 567:quantum/quantum.c ****     }
 568:quantum/quantum.c ****     default: {
 569:quantum/quantum.c ****       shift_interrupted[0] = true;
 536               		.loc 1 569 0
 537 0082 81E0      		ldi r24,lo8(1)
 538 0084 8093 0000 		sts shift_interrupted,r24
 570:quantum/quantum.c ****       shift_interrupted[1] = true;
 539               		.loc 1 570 0
 540 0088 8093 0000 		sts shift_interrupted+1,r24
 541               	.L58:
 571:quantum/quantum.c ****       break;
 572:quantum/quantum.c ****     }
 573:quantum/quantum.c ****   }
 574:quantum/quantum.c **** 
 575:quantum/quantum.c ****   return process_action_kb(record);
 542               		.loc 1 575 0
 543 008c C801      		movw r24,r16
 544               	/* epilogue start */
 576:quantum/quantum.c **** }
 545               		.loc 1 576 0
 546 008e DF91      		pop r29
 547 0090 CF91      		pop r28
 548               	.LVL54:
 549 0092 1F91      		pop r17
 550 0094 0F91      		pop r16
 551               	.LVL55:
 552 0096 FF90      		pop r15
 575:quantum/quantum.c **** }
 553               		.loc 1 575 0
 554 0098 0C94 0000 		jmp process_action_kb
 555               	.LVL56:
 556               	.L41:
 557               	.LBB25:
 185:quantum/quantum.c ****       }
 558               		.loc 1 185 0
 559 009c CE01      		movw r24,r28
 560 009e 0E94 0000 		call read_source_layers_cache
 561               	.LVL57:
 562 00a2 F82E      		mov r15,r24
 563               	.LVL58:
 564 00a4 00C0      		rjmp .L42
 565               	.LVL59:
 566               	.L40:
 567               	.LBE25:
 190:quantum/quantum.c **** 
 568               		.loc 1 190 0
 569 00a6 CE01      		movw r24,r28
 570 00a8 0E94 0000 		call layer_switch_get_layer
 571               	.LVL60:
 572 00ac BE01      		movw r22,r28
 573 00ae 00C0      		rjmp .L117
 574               	.LVL61:
 575               	.L49:
 254:quantum/quantum.c ****     case RESET:
 576               		.loc 1 254 0
 577 00b0 C53D      		cpi r28,-43
 578 00b2 ECE5      		ldi r30,92
 579 00b4 DE07      		cpc r29,r30
 580 00b6 01F4      		brne .+2
 581 00b8 00C0      		rjmp .L53
 582 00ba 00F4      		brsh .L54
 583 00bc C43D      		cpi r28,-44
 584 00be DC45      		sbci r29,92
 585 00c0 01F4      		brne .L47
 505:quantum/quantum.c ****         shift_interrupted[0] = false;
 586               		.loc 1 505 0
 587 00c2 F801      		movw r30,r16
 588 00c4 8281      		ldd r24,Z+2
 589 00c6 8823      		tst r24
 590 00c8 01F4      		brne .+2
 591 00ca 00C0      		rjmp .L81
 506:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 592               		.loc 1 506 0
 593 00cc 1092 0000 		sts shift_interrupted,__zero_reg__
 507:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 594               		.loc 1 507 0
 595 00d0 0E94 0000 		call timer_read
 596               	.LVL62:
 597 00d4 9093 0000 		sts scs_timer+1,r25
 598 00d8 8093 0000 		sts scs_timer,r24
 508:quantum/quantum.c ****       }
 599               		.loc 1 508 0
 600 00dc 82E0      		ldi r24,lo8(2)
 601               	.L120:
 530:quantum/quantum.c ****       }
 602               		.loc 1 530 0
 603 00de 0E94 0000 		call register_mods
 604               	.LVL63:
 605 00e2 00C0      		rjmp .L39
 606               	.L54:
 254:quantum/quantum.c ****     case RESET:
 607               		.loc 1 254 0
 608 00e4 C83D      		cpi r28,-40
 609 00e6 ECE5      		ldi r30,92
 610 00e8 DE07      		cpc r29,r30
 611 00ea 01F0      		breq .L56
 612 00ec C93D      		cpi r28,-39
 613 00ee DC45      		sbci r29,92
 614 00f0 01F4      		brne .L47
 408:quantum/quantum.c ****         set_output(OUTPUT_USB);
 615               		.loc 1 408 0
 616 00f2 F801      		movw r30,r16
 617 00f4 8281      		ldd r24,Z+2
 618 00f6 8823      		tst r24
 619 00f8 01F0      		breq .L39
 409:quantum/quantum.c ****       }
 620               		.loc 1 409 0
 621 00fa 82E0      		ldi r24,lo8(2)
 622 00fc 00C0      		rjmp .L119
 623               	.L52:
 256:quantum/quantum.c ****         reset_keyboard();
 624               		.loc 1 256 0
 625 00fe F801      		movw r30,r16
 626 0100 8281      		ldd r24,Z+2
 627 0102 8111      		cpse r24,__zero_reg__
 257:quantum/quantum.c ****       }
 628               		.loc 1 257 0
 629 0104 0E94 0000 		call reset_keyboard
 630               	.LVL64:
 631               	.L39:
 632               		.loc 1 576 0
 633 0108 80E0      		ldi r24,0
 634               	/* epilogue start */
 635 010a DF91      		pop r29
 636 010c CF91      		pop r28
 637               	.LVL65:
 638 010e 1F91      		pop r17
 639 0110 0F91      		pop r16
 640               	.LVL66:
 641 0112 FF90      		pop r15
 642 0114 0895      		ret
 643               	.LVL67:
 644               	.L50:
 261:quantum/quantum.c ****           debug_enable = true;
 645               		.loc 1 261 0
 646 0116 F801      		movw r30,r16
 647 0118 8281      		ldd r24,Z+2
 648 011a 8823      		tst r24
 649 011c 01F0      		breq .L39
 262:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 650               		.loc 1 262 0
 651 011e 8091 0000 		lds r24,debug_config
 652 0122 8160      		ori r24,lo8(1<<0)
 653 0124 8093 0000 		sts debug_config,r24
 654 0128 00C0      		rjmp .L39
 655               	.L56:
 403:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 656               		.loc 1 403 0
 657 012a F801      		movw r30,r16
 658 012c 8281      		ldd r24,Z+2
 659 012e 8823      		tst r24
 660 0130 01F0      		breq .L39
 404:quantum/quantum.c ****       }
 661               		.loc 1 404 0
 662 0132 80E0      		ldi r24,0
 663               	.L119:
 409:quantum/quantum.c ****       }
 664               		.loc 1 409 0
 665 0134 0E94 0000 		call set_output
 666               	.LVL68:
 667 0138 00C0      		rjmp .L39
 668               	.L51:
 421:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 669               		.loc 1 421 0
 670 013a F801      		movw r30,r16
 671 013c 8281      		ldd r24,Z+2
 672 013e 8823      		tst r24
 673 0140 01F4      		brne .+2
 674 0142 00C0      		rjmp .L58
 423:quantum/quantum.c ****             eeconfig_init();
 675               		.loc 1 423 0
 676 0144 0E94 0000 		call eeconfig_is_enabled
 677               	.LVL69:
 678 0148 8111      		cpse r24,__zero_reg__
 679 014a 00C0      		rjmp .L59
 424:quantum/quantum.c ****         }
 680               		.loc 1 424 0
 681 014c 0E94 0000 		call eeconfig_init
 682               	.LVL70:
 683               	.L59:
 427:quantum/quantum.c ****         switch (keycode)
 684               		.loc 1 427 0
 685 0150 0E94 0000 		call eeconfig_read_keymap
 686               	.LVL71:
 687 0154 90E0      		ldi r25,0
 688 0156 9093 0000 		sts keymap_config+1,r25
 689 015a 8093 0000 		sts keymap_config,r24
 428:quantum/quantum.c ****         {
 690               		.loc 1 428 0
 691 015e FE01      		movw r30,r28
 692 0160 E350      		subi r30,3
 693 0162 FC45      		sbci r31,92
 431:quantum/quantum.c ****             break;
 694               		.loc 1 431 0
 695 0164 8091 0000 		lds r24,keymap_config
 696 0168 8160      		ori r24,lo8(1<<0)
 428:quantum/quantum.c ****         {
 697               		.loc 1 428 0
 698 016a E231      		cpi r30,18
 699 016c F105      		cpc r31,__zero_reg__
 700 016e 00F4      		brsh .L118
 701 0170 E050      		subi r30,lo8(-(gs(.L62)))
 702 0172 F040      		sbci r31,hi8(-(gs(.L62)))
 703 0174 0C94 0000 		jmp __tablejump2__
 704               		.p2align	1
 705               	.L62:
 706 0178 0000      		.word gs(.L61)
 707 017a 0000      		.word gs(.L63)
 708 017c 0000      		.word gs(.L64)
 709 017e 0000      		.word gs(.L65)
 710 0180 0000      		.word gs(.L66)
 711 0182 0000      		.word gs(.L67)
 712 0184 0000      		.word gs(.L68)
 713 0186 0000      		.word gs(.L69)
 714 0188 0000      		.word gs(.L70)
 715 018a 0000      		.word gs(.L71)
 716 018c 0000      		.word gs(.L72)
 717 018e 0000      		.word gs(.L73)
 718 0190 0000      		.word gs(.L74)
 719 0192 0000      		.word gs(.L75)
 720 0194 0000      		.word gs(.L76)
 721 0196 0000      		.word gs(.L77)
 722 0198 0000      		.word gs(.L78)
 723 019a 0000      		.word gs(.L79)
 724               	.L61:
 434:quantum/quantum.c ****             break;
 725               		.loc 1 434 0
 726 019c 8091 0000 		lds r24,keymap_config
 727 01a0 8260      		ori r24,lo8(1<<1)
 728               	.L118:
 493:quantum/quantum.c ****             break;
 729               		.loc 1 493 0
 730 01a2 8093 0000 		sts keymap_config,r24
 498:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 731               		.loc 1 498 0
 732 01a6 8091 0000 		lds r24,keymap_config
 733 01aa 0E94 0000 		call eeconfig_update_keymap
 734               	.LVL72:
 499:quantum/quantum.c **** 
 735               		.loc 1 499 0
 736 01ae 0E94 0000 		call clear_keyboard
 737               	.LVL73:
 501:quantum/quantum.c ****       }
 738               		.loc 1 501 0
 739 01b2 00C0      		rjmp .L39
 740               	.L63:
 437:quantum/quantum.c ****             break;
 741               		.loc 1 437 0
 742 01b4 8091 0000 		lds r24,keymap_config
 743 01b8 8460      		ori r24,lo8(1<<2)
 744 01ba 00C0      		rjmp .L118
 745               	.L64:
 440:quantum/quantum.c ****             break;
 746               		.loc 1 440 0
 747 01bc 8091 0000 		lds r24,keymap_config
 748               	.L123:
 456:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 749               		.loc 1 456 0
 750 01c0 8860      		ori r24,lo8(1<<3)
 751 01c2 00C0      		rjmp .L118
 752               	.L65:
 443:quantum/quantum.c ****             break;
 753               		.loc 1 443 0
 754 01c4 8091 0000 		lds r24,keymap_config
 755 01c8 8061      		ori r24,lo8(1<<4)
 756 01ca 00C0      		rjmp .L118
 757               	.L66:
 446:quantum/quantum.c ****             break;
 758               		.loc 1 446 0
 759 01cc 8091 0000 		lds r24,keymap_config
 760 01d0 8062      		ori r24,lo8(1<<5)
 761 01d2 00C0      		rjmp .L118
 762               	.L67:
 449:quantum/quantum.c ****             break;
 763               		.loc 1 449 0
 764 01d4 8091 0000 		lds r24,keymap_config
 765 01d8 8064      		ori r24,lo8(1<<6)
 766 01da 00C0      		rjmp .L118
 767               	.L68:
 452:quantum/quantum.c ****             break;
 768               		.loc 1 452 0
 769 01dc 8091 0000 		lds r24,keymap_config
 770 01e0 8068      		ori r24,lo8(1<<7)
 771 01e2 00C0      		rjmp .L118
 772               	.L69:
 455:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 773               		.loc 1 455 0
 774 01e4 8091 0000 		lds r24,keymap_config
 456:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 775               		.loc 1 456 0
 776 01e8 8460      		ori r24,lo8(4)
 777 01ea 00C0      		rjmp .L123
 778               	.L70:
 462:quantum/quantum.c ****             break;
 779               		.loc 1 462 0
 780 01ec 8091 0000 		lds r24,keymap_config
 781 01f0 8E7F      		andi r24,lo8(~(1<<0))
 782 01f2 00C0      		rjmp .L118
 783               	.L71:
 465:quantum/quantum.c ****             break;
 784               		.loc 1 465 0
 785 01f4 8091 0000 		lds r24,keymap_config
 786 01f8 8D7F      		andi r24,lo8(~(1<<1))
 787 01fa 00C0      		rjmp .L118
 788               	.L72:
 468:quantum/quantum.c ****             break;
 789               		.loc 1 468 0
 790 01fc 8091 0000 		lds r24,keymap_config
 791 0200 8B7F      		andi r24,lo8(~(1<<2))
 792 0202 00C0      		rjmp .L118
 793               	.L73:
 471:quantum/quantum.c ****             break;
 794               		.loc 1 471 0
 795 0204 8091 0000 		lds r24,keymap_config
 796               	.L122:
 487:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 797               		.loc 1 487 0
 798 0208 877F      		andi r24,lo8(~(1<<3))
 799 020a 00C0      		rjmp .L118
 800               	.L74:
 474:quantum/quantum.c ****             break;
 801               		.loc 1 474 0
 802 020c 8091 0000 		lds r24,keymap_config
 803 0210 8F7E      		andi r24,lo8(~(1<<4))
 804 0212 00C0      		rjmp .L118
 805               	.L75:
 477:quantum/quantum.c ****             break;
 806               		.loc 1 477 0
 807 0214 8091 0000 		lds r24,keymap_config
 808 0218 8F7D      		andi r24,lo8(~(1<<5))
 809 021a 00C0      		rjmp .L118
 810               	.L76:
 480:quantum/quantum.c ****             break;
 811               		.loc 1 480 0
 812 021c 8091 0000 		lds r24,keymap_config
 813 0220 8F7B      		andi r24,lo8(~(1<<6))
 814 0222 00C0      		rjmp .L118
 815               	.L77:
 483:quantum/quantum.c ****             break;
 816               		.loc 1 483 0
 817 0224 8091 0000 		lds r24,keymap_config
 818 0228 8F77      		andi r24,lo8(~(1<<7))
 819 022a 00C0      		rjmp .L118
 820               	.L78:
 486:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 821               		.loc 1 486 0
 822 022c 8091 0000 		lds r24,keymap_config
 487:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 823               		.loc 1 487 0
 824 0230 8B7F      		andi r24,lo8(-5)
 825 0232 00C0      		rjmp .L122
 826               	.L79:
 493:quantum/quantum.c ****             break;
 827               		.loc 1 493 0
 828 0234 9091 0000 		lds r25,keymap_config
 829 0238 892F      		mov r24,r25
 830 023a 97FB      		bst r25,7
 831 023c 87F9      		bld r24,7
 832 023e 8058      		subi r24,0x80
 833 0240 00C0      		rjmp .L118
 834               	.L81:
 517:quantum/quantum.c ****           register_code(LSPO_KEY);
 835               		.loc 1 517 0
 836 0242 8091 0000 		lds r24,shift_interrupted
 837 0246 8111      		cpse r24,__zero_reg__
 838 0248 00C0      		rjmp .L83
 517:quantum/quantum.c ****           register_code(LSPO_KEY);
 839               		.loc 1 517 0 is_stmt 0 discriminator 1
 840 024a 8091 0000 		lds r24,scs_timer
 841 024e 9091 0000 		lds r25,scs_timer+1
 842 0252 0E94 0000 		call timer_elapsed
 843               	.LVL74:
 844 0256 883C      		cpi r24,-56
 845 0258 9105      		cpc r25,__zero_reg__
 846 025a 00F4      		brsh .L83
 518:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 847               		.loc 1 518 0 is_stmt 1
 848 025c 86E2      		ldi r24,lo8(38)
 849 025e 0E94 0000 		call register_code
 850               	.LVL75:
 519:quantum/quantum.c ****         }
 851               		.loc 1 519 0
 852 0262 86E2      		ldi r24,lo8(38)
 853 0264 0E94 0000 		call unregister_code
 854               	.LVL76:
 855               	.L83:
 521:quantum/quantum.c ****       }
 856               		.loc 1 521 0
 857 0268 82E0      		ldi r24,lo8(2)
 858               	.L121:
 543:quantum/quantum.c ****       }
 859               		.loc 1 543 0
 860 026a 0E94 0000 		call unregister_mods
 861               	.LVL77:
 862 026e 00C0      		rjmp .L39
 863               	.L53:
 527:quantum/quantum.c ****         shift_interrupted[1] = false;
 864               		.loc 1 527 0
 865 0270 F801      		movw r30,r16
 866 0272 8281      		ldd r24,Z+2
 867 0274 8823      		tst r24
 868 0276 01F0      		breq .L85
 528:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 869               		.loc 1 528 0
 870 0278 1092 0000 		sts shift_interrupted+1,__zero_reg__
 529:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 871               		.loc 1 529 0
 872 027c 0E94 0000 		call timer_read
 873               	.LVL78:
 874 0280 9093 0000 		sts scs_timer+2+1,r25
 875 0284 8093 0000 		sts scs_timer+2,r24
 530:quantum/quantum.c ****       }
 876               		.loc 1 530 0
 877 0288 80E2      		ldi r24,lo8(32)
 878 028a 00C0      		rjmp .L120
 879               	.L85:
 539:quantum/quantum.c ****           register_code(RSPC_KEY);
 880               		.loc 1 539 0
 881 028c 8091 0000 		lds r24,shift_interrupted+1
 882 0290 8111      		cpse r24,__zero_reg__
 883 0292 00C0      		rjmp .L87
 539:quantum/quantum.c ****           register_code(RSPC_KEY);
 884               		.loc 1 539 0 is_stmt 0 discriminator 1
 885 0294 8091 0000 		lds r24,scs_timer+2
 886 0298 9091 0000 		lds r25,scs_timer+2+1
 887 029c 0E94 0000 		call timer_elapsed
 888               	.LVL79:
 889 02a0 883C      		cpi r24,-56
 890 02a2 9105      		cpc r25,__zero_reg__
 891 02a4 00F4      		brsh .L87
 540:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 892               		.loc 1 540 0 is_stmt 1
 893 02a6 87E2      		ldi r24,lo8(39)
 894 02a8 0E94 0000 		call register_code
 895               	.LVL80:
 541:quantum/quantum.c ****         }
 896               		.loc 1 541 0
 897 02ac 87E2      		ldi r24,lo8(39)
 898 02ae 0E94 0000 		call unregister_code
 899               	.LVL81:
 900               	.L87:
 543:quantum/quantum.c ****       }
 901               		.loc 1 543 0
 902 02b2 80E2      		ldi r24,lo8(32)
 903 02b4 00C0      		rjmp .L121
 904               	.L48:
 905               	.LBB26:
 548:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 906               		.loc 1 548 0
 907 02b6 0E94 0000 		call get_mods
 908               	.LVL82:
 558:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 909               		.loc 1 558 0
 910 02ba F801      		movw r30,r16
 911 02bc 9281      		ldd r25,Z+2
 912 02be 9923      		tst r25
 913 02c0 01F0      		breq .L89
 548:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 914               		.loc 1 548 0
 915 02c2 8A7A      		andi r24,lo8(-86)
 916               	.LVL83:
 559:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 917               		.loc 1 559 0
 918 02c4 91E0      		ldi r25,lo8(1)
 919 02c6 01F4      		brne .L90
 920 02c8 90E0      		ldi r25,0
 921               	.L90:
 922 02ca 9093 0000 		sts grave_esc_was_shifted,r25
 560:quantum/quantum.c ****       }
 923               		.loc 1 560 0
 924 02ce 8111      		cpse r24,__zero_reg__
 925 02d0 00C0      		rjmp .L94
 926 02d2 89E2      		ldi r24,lo8(41)
 927               	.LVL84:
 928               	.L91:
 560:quantum/quantum.c ****       }
 929               		.loc 1 560 0 is_stmt 0 discriminator 4
 930 02d4 0E94 0000 		call add_key
 931               	.LVL85:
 932               	.L92:
 566:quantum/quantum.c ****     }
 933               		.loc 1 566 0 is_stmt 1
 934 02d8 0E94 0000 		call send_keyboard_report
 935               	.LVL86:
 936 02dc 00C0      		rjmp .L47
 937               	.LVL87:
 938               	.L94:
 560:quantum/quantum.c ****       }
 939               		.loc 1 560 0
 940 02de 85E3      		ldi r24,lo8(53)
 941               	.LVL88:
 942 02e0 00C0      		rjmp .L91
 943               	.LVL89:
 944               	.L89:
 563:quantum/quantum.c ****       }
 945               		.loc 1 563 0
 946 02e2 8091 0000 		lds r24,grave_esc_was_shifted
 947               	.LVL90:
 948 02e6 8111      		cpse r24,__zero_reg__
 949 02e8 00C0      		rjmp .L95
 950 02ea 89E2      		ldi r24,lo8(41)
 951               	.L93:
 563:quantum/quantum.c ****       }
 952               		.loc 1 563 0 is_stmt 0 discriminator 4
 953 02ec 0E94 0000 		call del_key
 954               	.LVL91:
 955 02f0 00C0      		rjmp .L92
 956               	.L95:
 563:quantum/quantum.c ****       }
 957               		.loc 1 563 0
 958 02f2 85E3      		ldi r24,lo8(53)
 959 02f4 00C0      		rjmp .L93
 960               	.LBE26:
 961               		.cfi_endproc
 962               	.LFE121:
 964               		.section	.text.send_char,"ax",@progbits
 965               	.global	send_char
 967               	send_char:
 968               	.LFB126:
 577:quantum/quantum.c **** 
 578:quantum/quantum.c **** __attribute__ ((weak))
 579:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 580:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 581:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 582:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 583:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 584:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 585:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 586:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 587:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 588:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 589:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 590:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 591:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 592:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 593:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 594:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 595:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 596:quantum/quantum.c **** };
 597:quantum/quantum.c **** 
 598:quantum/quantum.c **** __attribute__ ((weak))
 599:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 600:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 601:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 602:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 603:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 604:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 605:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 606:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 607:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 608:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 609:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 610:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 611:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 612:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 613:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 614:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 615:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 616:quantum/quantum.c **** };
 617:quantum/quantum.c **** 
 618:quantum/quantum.c **** void send_string(const char *str) {
 619:quantum/quantum.c ****   send_string_with_delay(str, 0);
 620:quantum/quantum.c **** }
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** void send_string_P(const char *str) {
 623:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 624:quantum/quantum.c **** }
 625:quantum/quantum.c **** 
 626:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 627:quantum/quantum.c ****     while (1) {
 628:quantum/quantum.c ****         char ascii_code = *str;
 629:quantum/quantum.c ****         if (!ascii_code) break;
 630:quantum/quantum.c ****         if (ascii_code == 1) {
 631:quantum/quantum.c ****           // tap
 632:quantum/quantum.c ****           uint8_t keycode = *(++str);
 633:quantum/quantum.c ****           register_code(keycode);
 634:quantum/quantum.c ****           unregister_code(keycode);
 635:quantum/quantum.c ****         } else if (ascii_code == 2) {
 636:quantum/quantum.c ****           // down
 637:quantum/quantum.c ****           uint8_t keycode = *(++str);
 638:quantum/quantum.c ****           register_code(keycode);
 639:quantum/quantum.c ****         } else if (ascii_code == 3) {
 640:quantum/quantum.c ****           // up
 641:quantum/quantum.c ****           uint8_t keycode = *(++str);
 642:quantum/quantum.c ****           unregister_code(keycode);
 643:quantum/quantum.c ****         } else {
 644:quantum/quantum.c ****           send_char(ascii_code);
 645:quantum/quantum.c ****         }
 646:quantum/quantum.c ****         ++str;
 647:quantum/quantum.c ****         // interval
 648:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 649:quantum/quantum.c ****     }
 650:quantum/quantum.c **** }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 653:quantum/quantum.c ****     while (1) {
 654:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 655:quantum/quantum.c ****         if (!ascii_code) break;
 656:quantum/quantum.c ****         if (ascii_code == 1) {
 657:quantum/quantum.c ****           // tap
 658:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 659:quantum/quantum.c ****           register_code(keycode);
 660:quantum/quantum.c ****           unregister_code(keycode);
 661:quantum/quantum.c ****         } else if (ascii_code == 2) {
 662:quantum/quantum.c ****           // down
 663:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 664:quantum/quantum.c ****           register_code(keycode);
 665:quantum/quantum.c ****         } else if (ascii_code == 3) {
 666:quantum/quantum.c ****           // up
 667:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 668:quantum/quantum.c ****           unregister_code(keycode);
 669:quantum/quantum.c ****         } else {
 670:quantum/quantum.c ****           send_char(ascii_code);
 671:quantum/quantum.c ****         }
 672:quantum/quantum.c ****         ++str;
 673:quantum/quantum.c ****         // interval
 674:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 675:quantum/quantum.c ****     }
 676:quantum/quantum.c **** }
 677:quantum/quantum.c **** 
 678:quantum/quantum.c **** void send_char(char ascii_code) {
 969               		.loc 1 678 0 is_stmt 1
 970               		.cfi_startproc
 971               	.LVL92:
 972 0000 CF93      		push r28
 973               	.LCFI13:
 974               		.cfi_def_cfa_offset 3
 975               		.cfi_offset 28, -2
 976               	/* prologue: function */
 977               	/* frame size = 0 */
 978               	/* stack size = 1 */
 979               	.L__stack_usage = 1
 980 0002 90E0      		ldi r25,0
 981               	.LVL93:
 982               	.LBB27:
 679:quantum/quantum.c ****   uint8_t keycode;
 680:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 983               		.loc 1 680 0
 984 0004 FC01      		movw r30,r24
 985 0006 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 986 0008 F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 987               	.LVL94:
 988               	/* #APP */
 989               	 ;  680 "quantum/quantum.c" 1
 990 000a C491      		lpm r28, Z
 991               		
 992               	 ;  0 "" 2
 993               	.LVL95:
 994               	/* #NOAPP */
 995               	.LBE27:
 996               	.LBB28:
 681:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 997               		.loc 1 681 0
 998 000c 8050      		subi r24,lo8(-(ascii_to_shift_lut))
 999 000e 9040      		sbci r25,hi8(-(ascii_to_shift_lut))
 1000               	.LVL96:
 1001 0010 FC01      		movw r30,r24
 1002               	.LVL97:
 1003               	/* #APP */
 1004               	 ;  681 "quantum/quantum.c" 1
 1005 0012 8491      		lpm r24, Z
 1006               		
 1007               	 ;  0 "" 2
 1008               	.LVL98:
 1009               	/* #NOAPP */
 1010               	.LBE28:
 1011 0014 8823      		tst r24
 1012 0016 01F0      		breq .L125
 682:quantum/quantum.c ****       register_code(KC_LSFT);
 1013               		.loc 1 682 0
 1014 0018 81EE      		ldi r24,lo8(-31)
 1015               	.LVL99:
 1016 001a 0E94 0000 		call register_code
 1017               	.LVL100:
 683:quantum/quantum.c ****       register_code(keycode);
 1018               		.loc 1 683 0
 1019 001e 8C2F      		mov r24,r28
 1020 0020 0E94 0000 		call register_code
 1021               	.LVL101:
 684:quantum/quantum.c ****       unregister_code(keycode);
 1022               		.loc 1 684 0
 1023 0024 8C2F      		mov r24,r28
 1024 0026 0E94 0000 		call unregister_code
 1025               	.LVL102:
 685:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1026               		.loc 1 685 0
 1027 002a 81EE      		ldi r24,lo8(-31)
 1028               	.L126:
 1029               	/* epilogue start */
 686:quantum/quantum.c ****   } else {
 687:quantum/quantum.c ****       register_code(keycode);
 688:quantum/quantum.c ****       unregister_code(keycode);
 689:quantum/quantum.c ****   }
 690:quantum/quantum.c **** }
 1030               		.loc 1 690 0
 1031 002c CF91      		pop r28
 1032               	.LVL103:
 688:quantum/quantum.c ****   }
 1033               		.loc 1 688 0
 1034 002e 0C94 0000 		jmp unregister_code
 1035               	.LVL104:
 1036               	.L125:
 687:quantum/quantum.c ****       unregister_code(keycode);
 1037               		.loc 1 687 0
 1038 0032 8C2F      		mov r24,r28
 1039               	.LVL105:
 1040 0034 0E94 0000 		call register_code
 1041               	.LVL106:
 688:quantum/quantum.c ****   }
 1042               		.loc 1 688 0
 1043 0038 8C2F      		mov r24,r28
 1044 003a 00C0      		rjmp .L126
 1045               		.cfi_endproc
 1046               	.LFE126:
 1048               		.section	.text.send_string_with_delay,"ax",@progbits
 1049               	.global	send_string_with_delay
 1051               	send_string_with_delay:
 1052               	.LFB124:
 626:quantum/quantum.c ****     while (1) {
 1053               		.loc 1 626 0
 1054               		.cfi_startproc
 1055               	.LVL107:
 1056 0000 FF92      		push r15
 1057               	.LCFI14:
 1058               		.cfi_def_cfa_offset 3
 1059               		.cfi_offset 15, -2
 1060 0002 0F93      		push r16
 1061               	.LCFI15:
 1062               		.cfi_def_cfa_offset 4
 1063               		.cfi_offset 16, -3
 1064 0004 1F93      		push r17
 1065               	.LCFI16:
 1066               		.cfi_def_cfa_offset 5
 1067               		.cfi_offset 17, -4
 1068 0006 CF93      		push r28
 1069               	.LCFI17:
 1070               		.cfi_def_cfa_offset 6
 1071               		.cfi_offset 28, -5
 1072 0008 DF93      		push r29
 1073               	.LCFI18:
 1074               		.cfi_def_cfa_offset 7
 1075               		.cfi_offset 29, -6
 1076               	/* prologue: function */
 1077               	/* frame size = 0 */
 1078               	/* stack size = 5 */
 1079               	.L__stack_usage = 5
 1080 000a EC01      		movw r28,r24
 1081 000c F62E      		mov r15,r22
 1082               	.LVL108:
 1083               	.L135:
 1084               	.LBB29:
 628:quantum/quantum.c ****         if (!ascii_code) break;
 1085               		.loc 1 628 0
 1086 000e 8881      		ld r24,Y
 1087               	.LVL109:
 629:quantum/quantum.c ****         if (ascii_code == 1) {
 1088               		.loc 1 629 0
 1089 0010 8823      		tst r24
 1090 0012 01F0      		breq .L127
 1091 0014 8E01      		movw r16,r28
 1092 0016 0F5F      		subi r16,-1
 1093 0018 1F4F      		sbci r17,-1
 630:quantum/quantum.c ****           // tap
 1094               		.loc 1 630 0
 1095 001a 8130      		cpi r24,lo8(1)
 1096 001c 01F4      		brne .L129
 1097               	.LVL110:
 1098               	.LBB30:
 632:quantum/quantum.c ****           register_code(keycode);
 1099               		.loc 1 632 0
 1100 001e C981      		ldd r28,Y+1
 1101               	.LVL111:
 633:quantum/quantum.c ****           unregister_code(keycode);
 1102               		.loc 1 633 0
 1103 0020 8C2F      		mov r24,r28
 1104               	.LVL112:
 1105 0022 0E94 0000 		call register_code
 1106               	.LVL113:
 634:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1107               		.loc 1 634 0
 1108 0026 8C2F      		mov r24,r28
 1109               	.LVL114:
 1110               	.L136:
 1111               	.LBE30:
 1112               	.LBB31:
 642:quantum/quantum.c ****         } else {
 1113               		.loc 1 642 0
 1114 0028 0E94 0000 		call unregister_code
 1115               	.LVL115:
 1116               	.LBE31:
 1117 002c 00C0      		rjmp .L130
 1118               	.LVL116:
 1119               	.L129:
 635:quantum/quantum.c ****           // down
 1120               		.loc 1 635 0
 1121 002e 8230      		cpi r24,lo8(2)
 1122 0030 01F4      		brne .L131
 1123               	.LVL117:
 1124               	.LBB32:
 638:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1125               		.loc 1 638 0
 1126 0032 8981      		ldd r24,Y+1
 1127               	.LVL118:
 1128 0034 0E94 0000 		call register_code
 1129               	.LVL119:
 1130               	.L130:
 1131               	.LBE32:
 646:quantum/quantum.c ****         // interval
 1132               		.loc 1 646 0
 1133 0038 E801      		movw r28,r16
 1134 003a 2196      		adiw r28,1
 1135               	.LVL120:
 1136               	.LBB33:
 648:quantum/quantum.c ****     }
 1137               		.loc 1 648 0
 1138 003c 8F2D      		mov r24,r15
 1139               	.LVL121:
 1140               	.L133:
 648:quantum/quantum.c ****     }
 1141               		.loc 1 648 0 is_stmt 0 discriminator 1
 1142               	.LVL122:
 1143 003e 8150      		subi r24,1
 1144 0040 00F0      		brcs .L135
 1145               	.LBB34:
 1146               	.LBB35:
 1147               		.loc 2 187 0 is_stmt 1
 1148 0042 EFE9      		ldi r30,lo8(3999)
 1149 0044 FFE0      		ldi r31,hi8(3999)
 1150 0046 3197      	1:	sbiw r30,1
 1151 0048 01F4      		brne 1b
 1152 004a 00C0      		rjmp .
 1153 004c 0000      		nop
 1154 004e 00C0      		rjmp .L133
 1155               	.LVL123:
 1156               	.L131:
 1157               	.LBE35:
 1158               	.LBE34:
 1159               	.LBE33:
 639:quantum/quantum.c ****           // up
 1160               		.loc 1 639 0
 1161 0050 8330      		cpi r24,lo8(3)
 1162 0052 01F4      		brne .L132
 1163               	.LVL124:
 1164               	.LBB36:
 642:quantum/quantum.c ****         } else {
 1165               		.loc 1 642 0
 1166 0054 8981      		ldd r24,Y+1
 1167               	.LVL125:
 1168 0056 00C0      		rjmp .L136
 1169               	.LVL126:
 1170               	.L132:
 1171               	.LBE36:
 644:quantum/quantum.c ****         }
 1172               		.loc 1 644 0
 1173 0058 0E94 0000 		call send_char
 1174               	.LVL127:
 1175 005c 8E01      		movw r16,r28
 1176 005e 00C0      		rjmp .L130
 1177               	.LVL128:
 1178               	.L127:
 1179               	/* epilogue start */
 1180               	.LBE29:
 650:quantum/quantum.c **** 
 1181               		.loc 1 650 0
 1182 0060 DF91      		pop r29
 1183 0062 CF91      		pop r28
 1184               	.LVL129:
 1185 0064 1F91      		pop r17
 1186 0066 0F91      		pop r16
 1187 0068 FF90      		pop r15
 1188               	.LVL130:
 1189 006a 0895      		ret
 1190               		.cfi_endproc
 1191               	.LFE124:
 1193               		.section	.text.send_string,"ax",@progbits
 1194               	.global	send_string
 1196               	send_string:
 1197               	.LFB122:
 618:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1198               		.loc 1 618 0
 1199               		.cfi_startproc
 1200               	.LVL131:
 1201               	/* prologue: function */
 1202               	/* frame size = 0 */
 1203               	/* stack size = 0 */
 1204               	.L__stack_usage = 0
 619:quantum/quantum.c **** }
 1205               		.loc 1 619 0
 1206 0000 60E0      		ldi r22,0
 1207 0002 0C94 0000 		jmp send_string_with_delay
 1208               	.LVL132:
 1209               		.cfi_endproc
 1210               	.LFE122:
 1212               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1213               	.global	send_string_with_delay_P
 1215               	send_string_with_delay_P:
 1216               	.LFB125:
 652:quantum/quantum.c ****     while (1) {
 1217               		.loc 1 652 0
 1218               		.cfi_startproc
 1219               	.LVL133:
 1220 0000 FF92      		push r15
 1221               	.LCFI19:
 1222               		.cfi_def_cfa_offset 3
 1223               		.cfi_offset 15, -2
 1224 0002 0F93      		push r16
 1225               	.LCFI20:
 1226               		.cfi_def_cfa_offset 4
 1227               		.cfi_offset 16, -3
 1228 0004 1F93      		push r17
 1229               	.LCFI21:
 1230               		.cfi_def_cfa_offset 5
 1231               		.cfi_offset 17, -4
 1232 0006 CF93      		push r28
 1233               	.LCFI22:
 1234               		.cfi_def_cfa_offset 6
 1235               		.cfi_offset 28, -5
 1236 0008 DF93      		push r29
 1237               	.LCFI23:
 1238               		.cfi_def_cfa_offset 7
 1239               		.cfi_offset 29, -6
 1240               	/* prologue: function */
 1241               	/* frame size = 0 */
 1242               	/* stack size = 5 */
 1243               	.L__stack_usage = 5
 1244 000a 8C01      		movw r16,r24
 1245 000c F62E      		mov r15,r22
 1246               	.LVL134:
 1247               	.L146:
 1248               	.LBB37:
 1249               	.LBB38:
 654:quantum/quantum.c ****         if (!ascii_code) break;
 1250               		.loc 1 654 0
 1251 000e F801      		movw r30,r16
 1252               	/* #APP */
 1253               	 ;  654 "quantum/quantum.c" 1
 1254 0010 8491      		lpm r24, Z
 1255               		
 1256               	 ;  0 "" 2
 1257               	.LVL135:
 1258               	/* #NOAPP */
 1259               	.LBE38:
 655:quantum/quantum.c ****         if (ascii_code == 1) {
 1260               		.loc 1 655 0
 1261 0012 8823      		tst r24
 1262 0014 01F0      		breq .L138
 1263 0016 E801      		movw r28,r16
 1264 0018 2196      		adiw r28,1
 656:quantum/quantum.c ****           // tap
 1265               		.loc 1 656 0
 1266 001a 8130      		cpi r24,lo8(1)
 1267 001c 01F4      		brne .L140
 1268               	.LVL136:
 1269               	.LBB39:
 1270               	.LBB40:
 658:quantum/quantum.c ****           register_code(keycode);
 1271               		.loc 1 658 0
 1272 001e FE01      		movw r30,r28
 1273               	/* #APP */
 1274               	 ;  658 "quantum/quantum.c" 1
 1275 0020 1491      		lpm r17, Z
 1276               		
 1277               	 ;  0 "" 2
 1278               	.LVL137:
 1279               	/* #NOAPP */
 1280               	.LBE40:
 659:quantum/quantum.c ****           unregister_code(keycode);
 1281               		.loc 1 659 0
 1282 0022 812F      		mov r24,r17
 1283               	.LVL138:
 1284 0024 0E94 0000 		call register_code
 1285               	.LVL139:
 660:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1286               		.loc 1 660 0
 1287 0028 812F      		mov r24,r17
 1288               	.LVL140:
 1289               	.L147:
 1290               	.LBE39:
 1291               	.LBB41:
 668:quantum/quantum.c ****         } else {
 1292               		.loc 1 668 0
 1293 002a 0E94 0000 		call unregister_code
 1294               	.LVL141:
 1295               	.LBE41:
 1296 002e 00C0      		rjmp .L141
 1297               	.LVL142:
 1298               	.L140:
 661:quantum/quantum.c ****           // down
 1299               		.loc 1 661 0
 1300 0030 8230      		cpi r24,lo8(2)
 1301 0032 01F4      		brne .L142
 1302               	.LVL143:
 1303               	.LBB43:
 1304               	.LBB44:
 663:quantum/quantum.c ****           register_code(keycode);
 1305               		.loc 1 663 0
 1306 0034 FE01      		movw r30,r28
 1307               	/* #APP */
 1308               	 ;  663 "quantum/quantum.c" 1
 1309 0036 8491      		lpm r24, Z
 1310               		
 1311               	 ;  0 "" 2
 1312               	.LVL144:
 1313               	/* #NOAPP */
 1314               	.LBE44:
 664:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1315               		.loc 1 664 0
 1316 0038 0E94 0000 		call register_code
 1317               	.LVL145:
 1318               	.L141:
 1319               	.LBE43:
 672:quantum/quantum.c ****         // interval
 1320               		.loc 1 672 0
 1321 003c 8E01      		movw r16,r28
 1322 003e 0F5F      		subi r16,-1
 1323 0040 1F4F      		sbci r17,-1
 1324               	.LVL146:
 1325               	.LBB45:
 674:quantum/quantum.c ****     }
 1326               		.loc 1 674 0
 1327 0042 8F2D      		mov r24,r15
 1328               	.LVL147:
 1329               	.L144:
 674:quantum/quantum.c ****     }
 1330               		.loc 1 674 0 is_stmt 0 discriminator 1
 1331               	.LVL148:
 1332 0044 8150      		subi r24,1
 1333 0046 00F0      		brcs .L146
 1334               	.LBB46:
 1335               	.LBB47:
 1336               		.loc 2 187 0 is_stmt 1
 1337 0048 EFE9      		ldi r30,lo8(3999)
 1338 004a FFE0      		ldi r31,hi8(3999)
 1339 004c 3197      	1:	sbiw r30,1
 1340 004e 01F4      		brne 1b
 1341 0050 00C0      		rjmp .
 1342 0052 0000      		nop
 1343 0054 00C0      		rjmp .L144
 1344               	.LVL149:
 1345               	.L142:
 1346               	.LBE47:
 1347               	.LBE46:
 1348               	.LBE45:
 665:quantum/quantum.c ****           // up
 1349               		.loc 1 665 0
 1350 0056 8330      		cpi r24,lo8(3)
 1351 0058 01F4      		brne .L143
 1352               	.LVL150:
 1353               	.LBB48:
 1354               	.LBB42:
 667:quantum/quantum.c ****           unregister_code(keycode);
 1355               		.loc 1 667 0
 1356 005a FE01      		movw r30,r28
 1357               	/* #APP */
 1358               	 ;  667 "quantum/quantum.c" 1
 1359 005c 8491      		lpm r24, Z
 1360               		
 1361               	 ;  0 "" 2
 1362               	.LVL151:
 1363               	/* #NOAPP */
 1364 005e 00C0      		rjmp .L147
 1365               	.LVL152:
 1366               	.L143:
 1367               	.LBE42:
 1368               	.LBE48:
 670:quantum/quantum.c ****         }
 1369               		.loc 1 670 0
 1370 0060 0E94 0000 		call send_char
 1371               	.LVL153:
 1372 0064 E801      		movw r28,r16
 1373 0066 00C0      		rjmp .L141
 1374               	.LVL154:
 1375               	.L138:
 1376               	/* epilogue start */
 1377               	.LBE37:
 676:quantum/quantum.c **** 
 1378               		.loc 1 676 0
 1379 0068 DF91      		pop r29
 1380 006a CF91      		pop r28
 1381 006c 1F91      		pop r17
 1382 006e 0F91      		pop r16
 1383               	.LVL155:
 1384 0070 FF90      		pop r15
 1385               	.LVL156:
 1386 0072 0895      		ret
 1387               		.cfi_endproc
 1388               	.LFE125:
 1390               		.section	.text.send_string_P,"ax",@progbits
 1391               	.global	send_string_P
 1393               	send_string_P:
 1394               	.LFB123:
 622:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1395               		.loc 1 622 0
 1396               		.cfi_startproc
 1397               	.LVL157:
 1398               	/* prologue: function */
 1399               	/* frame size = 0 */
 1400               	/* stack size = 0 */
 1401               	.L__stack_usage = 0
 623:quantum/quantum.c **** }
 1402               		.loc 1 623 0
 1403 0000 60E0      		ldi r22,0
 1404 0002 0C94 0000 		jmp send_string_with_delay_P
 1405               	.LVL158:
 1406               		.cfi_endproc
 1407               	.LFE123:
 1409               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1410               	.global	set_single_persistent_default_layer
 1412               	set_single_persistent_default_layer:
 1413               	.LFB127:
 691:quantum/quantum.c **** 
 692:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1414               		.loc 1 692 0
 1415               		.cfi_startproc
 1416               	.LVL159:
 1417 0000 CF93      		push r28
 1418               	.LCFI24:
 1419               		.cfi_def_cfa_offset 3
 1420               		.cfi_offset 28, -2
 1421 0002 DF93      		push r29
 1422               	.LCFI25:
 1423               		.cfi_def_cfa_offset 4
 1424               		.cfi_offset 29, -3
 1425               	/* prologue: function */
 1426               	/* frame size = 0 */
 1427               	/* stack size = 2 */
 1428               	.L__stack_usage = 2
 693:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 694:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 695:quantum/quantum.c ****   #endif
 696:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1429               		.loc 1 696 0
 1430 0004 C1E0      		ldi r28,lo8(1)
 1431 0006 D0E0      		ldi r29,0
 1432 0008 00C0      		rjmp 2f
 1433               		1:
 1434 000a CC0F      		lsl r28
 1435 000c DD1F      		rol r29
 1436               		2:
 1437 000e 8A95      		dec r24
 1438 0010 02F4      		brpl 1b
 1439 0012 8C2F      		mov r24,r28
 1440               	.LVL160:
 1441 0014 0E94 0000 		call eeconfig_update_default_layer
 1442               	.LVL161:
 697:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1443               		.loc 1 697 0
 1444 0018 BE01      		movw r22,r28
 1445 001a 90E0      		ldi r25,0
 1446 001c 80E0      		ldi r24,0
 1447               	/* epilogue start */
 698:quantum/quantum.c **** }
 1448               		.loc 1 698 0
 1449 001e DF91      		pop r29
 1450 0020 CF91      		pop r28
 697:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1451               		.loc 1 697 0
 1452 0022 0C94 0000 		jmp default_layer_set
 1453               	.LVL162:
 1454               		.cfi_endproc
 1455               	.LFE127:
 1457               		.section	.text.update_tri_layer,"ax",@progbits
 1458               	.global	update_tri_layer
 1460               	update_tri_layer:
 1461               	.LFB128:
 699:quantum/quantum.c **** 
 700:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1462               		.loc 1 700 0
 1463               		.cfi_startproc
 1464               	.LVL163:
 1465 0000 8F92      		push r8
 1466               	.LCFI26:
 1467               		.cfi_def_cfa_offset 3
 1468               		.cfi_offset 8, -2
 1469 0002 9F92      		push r9
 1470               	.LCFI27:
 1471               		.cfi_def_cfa_offset 4
 1472               		.cfi_offset 9, -3
 1473 0004 AF92      		push r10
 1474               	.LCFI28:
 1475               		.cfi_def_cfa_offset 5
 1476               		.cfi_offset 10, -4
 1477 0006 BF92      		push r11
 1478               	.LCFI29:
 1479               		.cfi_def_cfa_offset 6
 1480               		.cfi_offset 11, -5
 1481 0008 CF92      		push r12
 1482               	.LCFI30:
 1483               		.cfi_def_cfa_offset 7
 1484               		.cfi_offset 12, -6
 1485 000a DF92      		push r13
 1486               	.LCFI31:
 1487               		.cfi_def_cfa_offset 8
 1488               		.cfi_offset 13, -7
 1489 000c EF92      		push r14
 1490               	.LCFI32:
 1491               		.cfi_def_cfa_offset 9
 1492               		.cfi_offset 14, -8
 1493 000e FF92      		push r15
 1494               	.LCFI33:
 1495               		.cfi_def_cfa_offset 10
 1496               		.cfi_offset 15, -9
 1497 0010 0F93      		push r16
 1498               	.LCFI34:
 1499               		.cfi_def_cfa_offset 11
 1500               		.cfi_offset 16, -10
 1501 0012 1F93      		push r17
 1502               	.LCFI35:
 1503               		.cfi_def_cfa_offset 12
 1504               		.cfi_offset 17, -11
 1505               	/* prologue: function */
 1506               	/* frame size = 0 */
 1507               	/* stack size = 10 */
 1508               	.L__stack_usage = 10
 1509 0014 C12C      		mov r12,__zero_reg__
 1510 0016 D12C      		mov r13,__zero_reg__
 1511 0018 7601      		movw r14,r12
 1512 001a C394      		inc r12
 1513 001c 9701      		movw r18,r14
 1514 001e 8601      		movw r16,r12
 1515 0020 00C0      		rjmp 2f
 1516               		1:
 1517 0022 000F      		lsl r16
 1518 0024 111F      		rol r17
 1519 0026 221F      		rol r18
 1520 0028 331F      		rol r19
 1521               		2:
 1522 002a 6A95      		dec r22
 1523 002c 02F4      		brpl 1b
 1524 002e 4601      		movw r8,r12
 1525 0030 5701      		movw r10,r14
 1526 0032 00C0      		rjmp 2f
 1527               		1:
 1528 0034 880C      		lsl r8
 1529 0036 991C      		rol r9
 1530 0038 AA1C      		rol r10
 1531 003a BB1C      		rol r11
 1532               		2:
 1533 003c 8A95      		dec r24
 1534 003e 02F4      		brpl 1b
 1535 0040 D501      		movw r26,r10
 1536 0042 C401      		movw r24,r8
 1537               	.LVL164:
 1538 0044 802B      		or r24,r16
 1539 0046 912B      		or r25,r17
 1540 0048 A22B      		or r26,r18
 1541 004a B32B      		or r27,r19
 701:quantum/quantum.c ****   if (IS_LAYER_ON(layer1) && IS_LAYER_ON(layer2)) {
 1542               		.loc 1 701 0
 1543 004c 0091 0000 		lds r16,layer_state
 1544 0050 1091 0000 		lds r17,layer_state+1
 1545 0054 2091 0000 		lds r18,layer_state+2
 1546 0058 3091 0000 		lds r19,layer_state+3
 1547 005c 0823      		and r16,r24
 1548 005e 1923      		and r17,r25
 1549 0060 2A23      		and r18,r26
 1550 0062 3B23      		and r19,r27
 1551 0064 8017      		cp r24,r16
 1552 0066 9107      		cpc r25,r17
 1553 0068 A207      		cpc r26,r18
 1554 006a B307      		cpc r27,r19
 1555 006c 01F4      		brne .L151
 702:quantum/quantum.c ****     layer_on(layer3);
 1556               		.loc 1 702 0
 1557 006e 842F      		mov r24,r20
 1558               	/* epilogue start */
 703:quantum/quantum.c ****   } else {
 704:quantum/quantum.c ****     layer_off(layer3);
 705:quantum/quantum.c ****   }
 706:quantum/quantum.c **** }
 1559               		.loc 1 706 0
 1560 0070 1F91      		pop r17
 1561 0072 0F91      		pop r16
 1562 0074 FF90      		pop r15
 1563 0076 EF90      		pop r14
 1564 0078 DF90      		pop r13
 1565 007a CF90      		pop r12
 1566 007c BF90      		pop r11
 1567 007e AF90      		pop r10
 1568 0080 9F90      		pop r9
 1569 0082 8F90      		pop r8
 702:quantum/quantum.c ****     layer_on(layer3);
 1570               		.loc 1 702 0
 1571 0084 0C94 0000 		jmp layer_on
 1572               	.LVL165:
 1573               	.L151:
 704:quantum/quantum.c ****   }
 1574               		.loc 1 704 0
 1575 0088 842F      		mov r24,r20
 1576               	/* epilogue start */
 1577               		.loc 1 706 0
 1578 008a 1F91      		pop r17
 1579 008c 0F91      		pop r16
 1580 008e FF90      		pop r15
 1581 0090 EF90      		pop r14
 1582 0092 DF90      		pop r13
 1583 0094 CF90      		pop r12
 1584 0096 BF90      		pop r11
 1585 0098 AF90      		pop r10
 1586 009a 9F90      		pop r9
 1587 009c 8F90      		pop r8
 704:quantum/quantum.c ****   }
 1588               		.loc 1 704 0
 1589 009e 0C94 0000 		jmp layer_off
 1590               	.LVL166:
 1591               		.cfi_endproc
 1592               	.LFE128:
 1594               		.section	.text.tap_random_base64,"ax",@progbits
 1595               	.global	tap_random_base64
 1597               	tap_random_base64:
 1598               	.LFB129:
 707:quantum/quantum.c **** 
 708:quantum/quantum.c **** void tap_random_base64(void) {
 1599               		.loc 1 708 0
 1600               		.cfi_startproc
 1601 0000 CF93      		push r28
 1602               	.LCFI36:
 1603               		.cfi_def_cfa_offset 3
 1604               		.cfi_offset 28, -2
 1605 0002 DF93      		push r29
 1606               	.LCFI37:
 1607               		.cfi_def_cfa_offset 4
 1608               		.cfi_offset 29, -3
 1609               	/* prologue: function */
 1610               	/* frame size = 0 */
 1611               	/* stack size = 2 */
 1612               	.L__stack_usage = 2
 709:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 710:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1613               		.loc 1 710 0
 1614 0004 46B5      		in r20,0x26
 1615 0006 2091 8400 		lds r18,132
 1616 000a 3091 8500 		lds r19,132+1
 1617 000e C091 9400 		lds r28,148
 1618 0012 D091 9500 		lds r29,148+1
 1619 0016 8091 BE00 		lds r24,190
 1620 001a 9091 BF00 		lds r25,190+1
 1621 001e C20F      		add r28,r18
 1622 0020 C40F      		add r28,r20
 1623 0022 C80F      		add r28,r24
 1624 0024 CF73      		andi r28,lo8(63)
 1625               	.LVL167:
 711:quantum/quantum.c ****   #else
 712:quantum/quantum.c ****     uint8_t key = rand() % 64;
 713:quantum/quantum.c ****   #endif
 714:quantum/quantum.c ****   switch (key) {
 1626               		.loc 1 714 0
 1627 0026 CE33      		cpi r28,lo8(62)
 1628 0028 00F4      		brsh .L154
 1629 002a C533      		cpi r28,lo8(53)
 1630 002c 00F4      		brsh .L155
 1631 002e CA31      		cpi r28,lo8(26)
 1632 0030 00F0      		brlo .L153
 1633 0032 C433      		cpi r28,lo8(52)
 1634 0034 00F4      		brsh .L160
 715:quantum/quantum.c ****     case 0 ... 25:
 716:quantum/quantum.c ****       register_code(KC_LSFT);
 717:quantum/quantum.c ****       register_code(key + KC_A);
 718:quantum/quantum.c ****       unregister_code(key + KC_A);
 719:quantum/quantum.c ****       unregister_code(KC_LSFT);
 720:quantum/quantum.c ****       break;
 721:quantum/quantum.c ****     case 26 ... 51:
 722:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1635               		.loc 1 722 0
 1636 0036 C651      		subi r28,lo8(-(-22))
 1637               	.LVL168:
 1638               	.L163:
 723:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 724:quantum/quantum.c ****       break;
 725:quantum/quantum.c ****     case 52:
 726:quantum/quantum.c ****       register_code(KC_0);
 727:quantum/quantum.c ****       unregister_code(KC_0);
 728:quantum/quantum.c ****       break;
 729:quantum/quantum.c ****     case 53 ... 61:
 730:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1639               		.loc 1 730 0
 1640 0038 8C2F      		mov r24,r28
 1641 003a 0E94 0000 		call register_code
 1642               	.LVL169:
 731:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1643               		.loc 1 731 0
 1644 003e 8C2F      		mov r24,r28
 1645 0040 00C0      		rjmp .L161
 1646               	.LVL170:
 1647               	.L154:
 714:quantum/quantum.c ****     case 0 ... 25:
 1648               		.loc 1 714 0
 1649 0042 CE33      		cpi r28,lo8(62)
 1650 0044 01F0      		breq .L158
 1651 0046 CF33      		cpi r28,lo8(63)
 1652 0048 01F0      		breq .L159
 1653               	.L153:
 716:quantum/quantum.c ****       register_code(key + KC_A);
 1654               		.loc 1 716 0
 1655 004a 81EE      		ldi r24,lo8(-31)
 1656 004c 0E94 0000 		call register_code
 1657               	.LVL171:
 717:quantum/quantum.c ****       unregister_code(key + KC_A);
 1658               		.loc 1 717 0
 1659 0050 CC5F      		subi r28,lo8(-(4))
 1660               	.LVL172:
 1661 0052 8C2F      		mov r24,r28
 1662 0054 0E94 0000 		call register_code
 1663               	.LVL173:
 718:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1664               		.loc 1 718 0
 1665 0058 8C2F      		mov r24,r28
 1666               	.LVL174:
 1667               	.L162:
 732:quantum/quantum.c ****       break;
 733:quantum/quantum.c ****     case 62:
 734:quantum/quantum.c ****       register_code(KC_LSFT);
 735:quantum/quantum.c ****       register_code(KC_EQL);
 736:quantum/quantum.c ****       unregister_code(KC_EQL);
 1668               		.loc 1 736 0
 1669 005a 0E94 0000 		call unregister_code
 1670               	.LVL175:
 737:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1671               		.loc 1 737 0
 1672 005e 81EE      		ldi r24,lo8(-31)
 1673 0060 00C0      		rjmp .L161
 1674               	.LVL176:
 1675               	.L160:
 726:quantum/quantum.c ****       unregister_code(KC_0);
 1676               		.loc 1 726 0
 1677 0062 87E2      		ldi r24,lo8(39)
 1678 0064 0E94 0000 		call register_code
 1679               	.LVL177:
 727:quantum/quantum.c ****       break;
 1680               		.loc 1 727 0
 1681 0068 87E2      		ldi r24,lo8(39)
 1682               	.LVL178:
 1683               	.L161:
 1684               	/* epilogue start */
 738:quantum/quantum.c ****       break;
 739:quantum/quantum.c ****     case 63:
 740:quantum/quantum.c ****       register_code(KC_SLSH);
 741:quantum/quantum.c ****       unregister_code(KC_SLSH);
 742:quantum/quantum.c ****       break;
 743:quantum/quantum.c ****   }
 744:quantum/quantum.c **** }
 1685               		.loc 1 744 0
 1686 006a DF91      		pop r29
 1687 006c CF91      		pop r28
 741:quantum/quantum.c ****       break;
 1688               		.loc 1 741 0
 1689 006e 0C94 0000 		jmp unregister_code
 1690               	.LVL179:
 1691               	.L155:
 730:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1692               		.loc 1 730 0
 1693 0072 C751      		subi r28,lo8(-(-23))
 1694               	.LVL180:
 1695 0074 00C0      		rjmp .L163
 1696               	.LVL181:
 1697               	.L158:
 734:quantum/quantum.c ****       register_code(KC_EQL);
 1698               		.loc 1 734 0
 1699 0076 81EE      		ldi r24,lo8(-31)
 1700 0078 0E94 0000 		call register_code
 1701               	.LVL182:
 735:quantum/quantum.c ****       unregister_code(KC_EQL);
 1702               		.loc 1 735 0
 1703 007c 8EE2      		ldi r24,lo8(46)
 1704 007e 0E94 0000 		call register_code
 1705               	.LVL183:
 736:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1706               		.loc 1 736 0
 1707 0082 8EE2      		ldi r24,lo8(46)
 1708 0084 00C0      		rjmp .L162
 1709               	.L159:
 740:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1710               		.loc 1 740 0
 1711 0086 88E3      		ldi r24,lo8(56)
 1712 0088 0E94 0000 		call register_code
 1713               	.LVL184:
 741:quantum/quantum.c ****       break;
 1714               		.loc 1 741 0
 1715 008c 88E3      		ldi r24,lo8(56)
 1716 008e 00C0      		rjmp .L161
 1717               		.cfi_endproc
 1718               	.LFE129:
 1720               		.section	.text.matrix_init_quantum,"ax",@progbits
 1721               	.global	matrix_init_quantum
 1723               	matrix_init_quantum:
 1724               	.LFB130:
 745:quantum/quantum.c **** 
 746:quantum/quantum.c **** void matrix_init_quantum() {
 1725               		.loc 1 746 0
 1726               		.cfi_startproc
 1727               	/* prologue: function */
 1728               	/* frame size = 0 */
 1729               	/* stack size = 0 */
 1730               	.L__stack_usage = 0
 747:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 748:quantum/quantum.c ****     backlight_init_ports();
 749:quantum/quantum.c ****   #endif
 750:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 751:quantum/quantum.c ****     audio_init();
 752:quantum/quantum.c ****   #endif
 753:quantum/quantum.c ****   matrix_init_kb();
 1731               		.loc 1 753 0
 1732 0000 0C94 0000 		jmp matrix_init_kb
 1733               	.LVL185:
 1734               		.cfi_endproc
 1735               	.LFE130:
 1737               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1738               	.global	matrix_scan_quantum
 1740               	matrix_scan_quantum:
 1741               	.LFB131:
 754:quantum/quantum.c **** }
 755:quantum/quantum.c **** 
 756:quantum/quantum.c **** void matrix_scan_quantum() {
 1742               		.loc 1 756 0
 1743               		.cfi_startproc
 1744               	/* prologue: function */
 1745               	/* frame size = 0 */
 1746               	/* stack size = 0 */
 1747               	.L__stack_usage = 0
 757:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 758:quantum/quantum.c ****     matrix_scan_music();
 759:quantum/quantum.c ****   #endif
 760:quantum/quantum.c **** 
 761:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 762:quantum/quantum.c ****     matrix_scan_tap_dance();
 763:quantum/quantum.c ****   #endif
 764:quantum/quantum.c **** 
 765:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 766:quantum/quantum.c ****     matrix_scan_combo();
 767:quantum/quantum.c ****   #endif
 768:quantum/quantum.c **** 
 769:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 770:quantum/quantum.c ****     backlight_task();
 771:quantum/quantum.c ****   #endif
 772:quantum/quantum.c **** 
 773:quantum/quantum.c ****   matrix_scan_kb();
 1748               		.loc 1 773 0
 1749 0000 0C94 0000 		jmp matrix_scan_kb
 1750               	.LVL186:
 1751               		.cfi_endproc
 1752               	.LFE131:
 1754               		.section	.text.backlight_init_ports,"ax",@progbits
 1755               		.weak	backlight_init_ports
 1757               	backlight_init_ports:
 1758               	.LFB151:
 1759               		.cfi_startproc
 1760               	/* prologue: function */
 1761               	/* frame size = 0 */
 1762               	/* stack size = 0 */
 1763               	.L__stack_usage = 0
 1764               	/* epilogue start */
 1765 0000 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE151:
 1769               		.section	.text.send_nibble,"ax",@progbits
 1770               	.global	send_nibble
 1772               	send_nibble:
 1773               	.LFB137:
 774:quantum/quantum.c **** }
 775:quantum/quantum.c **** 
 776:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 777:quantum/quantum.c **** 
 778:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 779:quantum/quantum.c **** 
 780:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 781:quantum/quantum.c **** #  define COM1x1 COM1C1
 782:quantum/quantum.c **** #  define OCR1x  OCR1C
 783:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 784:quantum/quantum.c **** #  define COM1x1 COM1B1
 785:quantum/quantum.c **** #  define OCR1x  OCR1B
 786:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 787:quantum/quantum.c **** #  define COM1x1 COM1A1
 788:quantum/quantum.c **** #  define OCR1x  OCR1A
 789:quantum/quantum.c **** #else
 790:quantum/quantum.c **** #  define NO_BACKLIGHT_CLOCK
 791:quantum/quantum.c **** #endif
 792:quantum/quantum.c **** 
 793:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 794:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 795:quantum/quantum.c **** #endif
 796:quantum/quantum.c **** 
 797:quantum/quantum.c **** __attribute__ ((weak))
 798:quantum/quantum.c **** void backlight_init_ports(void)
 799:quantum/quantum.c **** {
 800:quantum/quantum.c **** 
 801:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 802:quantum/quantum.c ****   // DDRx |= n
 803:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 804:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 805:quantum/quantum.c ****     // PORTx &= ~n
 806:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 807:quantum/quantum.c ****   #else
 808:quantum/quantum.c ****     // PORTx |= n
 809:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 810:quantum/quantum.c ****   #endif
 811:quantum/quantum.c **** 
 812:quantum/quantum.c ****   #ifndef NO_BACKLIGHT_CLOCK
 813:quantum/quantum.c ****     // Use full 16-bit resolution.
 814:quantum/quantum.c ****     ICR1 = 0xFFFF;
 815:quantum/quantum.c **** 
 816:quantum/quantum.c ****     // I could write a wall of text here to explain... but TL;DW
 817:quantum/quantum.c ****     // Go read the ATmega32u4 datasheet.
 818:quantum/quantum.c ****     // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolut
 819:quantum/quantum.c **** 
 820:quantum/quantum.c ****     // Pin PB7 = OCR1C (Timer 1, Channel C)
 821:quantum/quantum.c ****     // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
 822:quantum/quantum.c ****     // (i.e. start high, go low when counter matches.)
 823:quantum/quantum.c ****     // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
 824:quantum/quantum.c ****     // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
 825:quantum/quantum.c **** 
 826:quantum/quantum.c ****     TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
 827:quantum/quantum.c ****     TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
 828:quantum/quantum.c ****   #endif
 829:quantum/quantum.c **** 
 830:quantum/quantum.c ****   backlight_init();
 831:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
 832:quantum/quantum.c ****     breathing_defaults();
 833:quantum/quantum.c ****   #endif
 834:quantum/quantum.c **** }
 835:quantum/quantum.c **** 
 836:quantum/quantum.c **** __attribute__ ((weak))
 837:quantum/quantum.c **** void backlight_set(uint8_t level)
 838:quantum/quantum.c **** {
 839:quantum/quantum.c ****   // Prevent backlight blink on lowest level
 840:quantum/quantum.c ****   // #if BACKLIGHT_ON_STATE == 0
 841:quantum/quantum.c ****   //   // PORTx &= ~n
 842:quantum/quantum.c ****   //   _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 843:quantum/quantum.c ****   // #else
 844:quantum/quantum.c ****   //   // PORTx |= n
 845:quantum/quantum.c ****   //   _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 846:quantum/quantum.c ****   // #endif
 847:quantum/quantum.c **** 
 848:quantum/quantum.c ****   if ( level == 0 ) {
 849:quantum/quantum.c ****     #ifndef NO_BACKLIGHT_CLOCK
 850:quantum/quantum.c ****       // Turn off PWM control on backlight pin, revert to output low.
 851:quantum/quantum.c ****       TCCR1A &= ~(_BV(COM1x1));
 852:quantum/quantum.c ****       OCR1x = 0x0;
 853:quantum/quantum.c ****     #else
 854:quantum/quantum.c ****       // #if BACKLIGHT_ON_STATE == 0
 855:quantum/quantum.c ****       //   // PORTx |= n
 856:quantum/quantum.c ****       //   _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 857:quantum/quantum.c ****       // #else
 858:quantum/quantum.c ****       //   // PORTx &= ~n
 859:quantum/quantum.c ****       //   _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 860:quantum/quantum.c ****       // #endif
 861:quantum/quantum.c ****     #endif
 862:quantum/quantum.c ****   }
 863:quantum/quantum.c ****   #ifndef NO_BACKLIGHT_CLOCK
 864:quantum/quantum.c ****     else if ( level == BACKLIGHT_LEVELS ) {
 865:quantum/quantum.c ****       // Turn on PWM control of backlight pin
 866:quantum/quantum.c ****       TCCR1A |= _BV(COM1x1);
 867:quantum/quantum.c ****       // Set the brightness
 868:quantum/quantum.c ****       OCR1x = 0xFFFF;
 869:quantum/quantum.c ****     }
 870:quantum/quantum.c ****     else {
 871:quantum/quantum.c ****       // Turn on PWM control of backlight pin
 872:quantum/quantum.c ****       TCCR1A |= _BV(COM1x1);
 873:quantum/quantum.c ****       // Set the brightness
 874:quantum/quantum.c ****       OCR1x = 0xFFFF >> ((BACKLIGHT_LEVELS - level) * ((BACKLIGHT_LEVELS + 1) / 2));
 875:quantum/quantum.c ****     }
 876:quantum/quantum.c ****   #endif
 877:quantum/quantum.c **** 
 878:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
 879:quantum/quantum.c ****     breathing_intensity_default();
 880:quantum/quantum.c ****   #endif
 881:quantum/quantum.c **** }
 882:quantum/quantum.c **** 
 883:quantum/quantum.c **** uint8_t backlight_tick = 0;
 884:quantum/quantum.c **** 
 885:quantum/quantum.c **** void backlight_task(void) {
 886:quantum/quantum.c ****   #ifdef NO_BACKLIGHT_CLOCK
 887:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - backlight_config.level) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1
 888:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 889:quantum/quantum.c ****       // PORTx &= ~n
 890:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 891:quantum/quantum.c ****     #else
 892:quantum/quantum.c ****       // PORTx |= n
 893:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 894:quantum/quantum.c ****     #endif
 895:quantum/quantum.c ****   } else {
 896:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 897:quantum/quantum.c ****       // PORTx |= n
 898:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 899:quantum/quantum.c ****     #else
 900:quantum/quantum.c ****       // PORTx &= ~n
 901:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 902:quantum/quantum.c ****     #endif
 903:quantum/quantum.c ****   }
 904:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 905:quantum/quantum.c ****   #endif
 906:quantum/quantum.c **** }
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 909:quantum/quantum.c **** 
 910:quantum/quantum.c **** #define BREATHING_NO_HALT  0
 911:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
 912:quantum/quantum.c **** #define BREATHING_HALT_ON  2
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** static uint8_t breath_intensity;
 915:quantum/quantum.c **** static uint8_t breath_speed;
 916:quantum/quantum.c **** static uint16_t breathing_index;
 917:quantum/quantum.c **** static uint8_t breathing_halt;
 918:quantum/quantum.c **** 
 919:quantum/quantum.c **** void breathing_enable(void)
 920:quantum/quantum.c **** {
 921:quantum/quantum.c ****     if (get_backlight_level() == 0)
 922:quantum/quantum.c ****     {
 923:quantum/quantum.c ****         breathing_index = 0;
 924:quantum/quantum.c ****     }
 925:quantum/quantum.c ****     else
 926:quantum/quantum.c ****     {
 927:quantum/quantum.c ****         // Set breathing_index to be at the midpoint (brightest point)
 928:quantum/quantum.c ****         breathing_index = 0x20 << breath_speed;
 929:quantum/quantum.c ****     }
 930:quantum/quantum.c **** 
 931:quantum/quantum.c ****     breathing_halt = BREATHING_NO_HALT;
 932:quantum/quantum.c **** 
 933:quantum/quantum.c ****     // Enable breathing interrupt
 934:quantum/quantum.c ****     TIMSK1 |= _BV(OCIE1A);
 935:quantum/quantum.c **** }
 936:quantum/quantum.c **** 
 937:quantum/quantum.c **** void breathing_pulse(void)
 938:quantum/quantum.c **** {
 939:quantum/quantum.c ****     if (get_backlight_level() == 0)
 940:quantum/quantum.c ****     {
 941:quantum/quantum.c ****         breathing_index = 0;
 942:quantum/quantum.c ****     }
 943:quantum/quantum.c ****     else
 944:quantum/quantum.c ****     {
 945:quantum/quantum.c ****         // Set breathing_index to be at the midpoint + 1 (brightest point)
 946:quantum/quantum.c ****         breathing_index = 0x21 << breath_speed;
 947:quantum/quantum.c ****     }
 948:quantum/quantum.c **** 
 949:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
 950:quantum/quantum.c **** 
 951:quantum/quantum.c ****     // Enable breathing interrupt
 952:quantum/quantum.c ****     TIMSK1 |= _BV(OCIE1A);
 953:quantum/quantum.c **** }
 954:quantum/quantum.c **** 
 955:quantum/quantum.c **** void breathing_disable(void)
 956:quantum/quantum.c **** {
 957:quantum/quantum.c ****     // Disable breathing interrupt
 958:quantum/quantum.c ****     TIMSK1 &= ~_BV(OCIE1A);
 959:quantum/quantum.c ****     backlight_set(get_backlight_level());
 960:quantum/quantum.c **** }
 961:quantum/quantum.c **** 
 962:quantum/quantum.c **** void breathing_self_disable(void)
 963:quantum/quantum.c **** {
 964:quantum/quantum.c ****     if (get_backlight_level() == 0)
 965:quantum/quantum.c ****     {
 966:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_OFF;
 967:quantum/quantum.c ****     }
 968:quantum/quantum.c ****     else
 969:quantum/quantum.c ****     {
 970:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_ON;
 971:quantum/quantum.c ****     }
 972:quantum/quantum.c **** 
 973:quantum/quantum.c ****     //backlight_set(get_backlight_level());
 974:quantum/quantum.c **** }
 975:quantum/quantum.c **** 
 976:quantum/quantum.c **** void breathing_toggle(void)
 977:quantum/quantum.c **** {
 978:quantum/quantum.c ****     if (!is_breathing())
 979:quantum/quantum.c ****     {
 980:quantum/quantum.c ****         if (get_backlight_level() == 0)
 981:quantum/quantum.c ****         {
 982:quantum/quantum.c ****             breathing_index = 0;
 983:quantum/quantum.c ****         }
 984:quantum/quantum.c ****         else
 985:quantum/quantum.c ****         {
 986:quantum/quantum.c ****             // Set breathing_index to be at the midpoint + 1 (brightest point)
 987:quantum/quantum.c ****             breathing_index = 0x21 << breath_speed;
 988:quantum/quantum.c ****         }
 989:quantum/quantum.c **** 
 990:quantum/quantum.c ****         breathing_halt = BREATHING_NO_HALT;
 991:quantum/quantum.c ****     }
 992:quantum/quantum.c **** 
 993:quantum/quantum.c ****     // Toggle breathing interrupt
 994:quantum/quantum.c ****     TIMSK1 ^= _BV(OCIE1A);
 995:quantum/quantum.c **** 
 996:quantum/quantum.c ****     // Restore backlight level
 997:quantum/quantum.c ****     if (!is_breathing())
 998:quantum/quantum.c ****     {
 999:quantum/quantum.c ****         backlight_set(get_backlight_level());
1000:quantum/quantum.c ****     }
1001:quantum/quantum.c **** }
1002:quantum/quantum.c **** 
1003:quantum/quantum.c **** bool is_breathing(void)
1004:quantum/quantum.c **** {
1005:quantum/quantum.c ****     return (TIMSK1 && _BV(OCIE1A));
1006:quantum/quantum.c **** }
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** void breathing_intensity_default(void)
1009:quantum/quantum.c **** {
1010:quantum/quantum.c ****     //breath_intensity = (uint8_t)((uint16_t)100 * (uint16_t)get_backlight_level() / (uint16_t)BACK
1011:quantum/quantum.c ****     breath_intensity = ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2));
1012:quantum/quantum.c **** }
1013:quantum/quantum.c **** 
1014:quantum/quantum.c **** void breathing_intensity_set(uint8_t value)
1015:quantum/quantum.c **** {
1016:quantum/quantum.c ****     breath_intensity = value;
1017:quantum/quantum.c **** }
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** void breathing_speed_default(void)
1020:quantum/quantum.c **** {
1021:quantum/quantum.c ****     breath_speed = 4;
1022:quantum/quantum.c **** }
1023:quantum/quantum.c **** 
1024:quantum/quantum.c **** void breathing_speed_set(uint8_t value)
1025:quantum/quantum.c **** {
1026:quantum/quantum.c ****     bool is_breathing_now = is_breathing();
1027:quantum/quantum.c ****     uint8_t old_breath_speed = breath_speed;
1028:quantum/quantum.c **** 
1029:quantum/quantum.c ****     if (is_breathing_now)
1030:quantum/quantum.c ****     {
1031:quantum/quantum.c ****         // Disable breathing interrupt
1032:quantum/quantum.c ****         TIMSK1 &= ~_BV(OCIE1A);
1033:quantum/quantum.c ****     }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c ****     breath_speed = value;
1036:quantum/quantum.c **** 
1037:quantum/quantum.c ****     if (is_breathing_now)
1038:quantum/quantum.c ****     {
1039:quantum/quantum.c ****         // Adjust index to account for new speed
1040:quantum/quantum.c ****         breathing_index = (( (uint8_t)( (breathing_index) >> old_breath_speed ) ) & 0x3F) << breath
1041:quantum/quantum.c **** 
1042:quantum/quantum.c ****         // Enable breathing interrupt
1043:quantum/quantum.c ****         TIMSK1 |= _BV(OCIE1A);
1044:quantum/quantum.c ****     }
1045:quantum/quantum.c **** 
1046:quantum/quantum.c **** }
1047:quantum/quantum.c **** 
1048:quantum/quantum.c **** void breathing_speed_inc(uint8_t value)
1049:quantum/quantum.c **** {
1050:quantum/quantum.c ****     if ((uint16_t)(breath_speed - value) > 10 )
1051:quantum/quantum.c ****     {
1052:quantum/quantum.c ****         breathing_speed_set(0);
1053:quantum/quantum.c ****     }
1054:quantum/quantum.c ****     else
1055:quantum/quantum.c ****     {
1056:quantum/quantum.c ****         breathing_speed_set(breath_speed - value);
1057:quantum/quantum.c ****     }
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_speed_dec(uint8_t value)
1061:quantum/quantum.c **** {
1062:quantum/quantum.c ****     if ((uint16_t)(breath_speed + value) > 10 )
1063:quantum/quantum.c ****     {
1064:quantum/quantum.c ****         breathing_speed_set(10);
1065:quantum/quantum.c ****     }
1066:quantum/quantum.c ****     else
1067:quantum/quantum.c ****     {
1068:quantum/quantum.c ****         breathing_speed_set(breath_speed + value);
1069:quantum/quantum.c ****     }
1070:quantum/quantum.c **** }
1071:quantum/quantum.c **** 
1072:quantum/quantum.c **** void breathing_defaults(void)
1073:quantum/quantum.c **** {
1074:quantum/quantum.c ****     breathing_intensity_default();
1075:quantum/quantum.c ****     breathing_speed_default();
1076:quantum/quantum.c ****     breathing_halt = BREATHING_NO_HALT;
1077:quantum/quantum.c **** }
1078:quantum/quantum.c **** 
1079:quantum/quantum.c **** /* Breathing Sleep LED brighness(PWM On period) table
1080:quantum/quantum.c ****  * (64[steps] * 4[duration]) / 64[PWM periods/s] = 4 second breath cycle
1081:quantum/quantum.c ****  *
1082:quantum/quantum.c ****  * http://www.wolframalpha.com/input/?i=%28sin%28+x%2F64*pi%29**8+*+255%2C+x%3D0+to+63
1083:quantum/quantum.c ****  * (0..63).each {|x| p ((sin(x/64.0*PI)**8)*255).to_i }
1084:quantum/quantum.c ****  */
1085:quantum/quantum.c **** static const uint8_t breathing_table[64] PROGMEM = {
1086:quantum/quantum.c ****   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   4,   6,  10,
1087:quantum/quantum.c ****  15,  23,  32,  44,  58,  74,  93, 113, 135, 157, 179, 199, 218, 233, 245, 252,
1088:quantum/quantum.c **** 255, 252, 245, 233, 218, 199, 179, 157, 135, 113,  93,  74,  58,  44,  32,  23,
1089:quantum/quantum.c ****  15,  10,   6,   4,   2,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
1090:quantum/quantum.c **** };
1091:quantum/quantum.c **** 
1092:quantum/quantum.c **** ISR(TIMER1_COMPA_vect)
1093:quantum/quantum.c **** {
1094:quantum/quantum.c ****     // OCR1x = (pgm_read_byte(&breathing_table[ ( (uint8_t)( (breathing_index++) >> breath_speed ) 
1095:quantum/quantum.c **** 
1096:quantum/quantum.c **** 
1097:quantum/quantum.c ****     uint8_t local_index = ( (uint8_t)( (breathing_index++) >> breath_speed ) ) & 0x3F;
1098:quantum/quantum.c **** 
1099:quantum/quantum.c ****     if (((breathing_halt == BREATHING_HALT_ON) && (local_index == 0x20)) || ((breathing_halt == BRE
1100:quantum/quantum.c ****     {
1101:quantum/quantum.c ****         // Disable breathing interrupt
1102:quantum/quantum.c ****         TIMSK1 &= ~_BV(OCIE1A);
1103:quantum/quantum.c ****     }
1104:quantum/quantum.c **** 
1105:quantum/quantum.c ****     OCR1x = (uint16_t)(((uint16_t)pgm_read_byte(&breathing_table[local_index]) * 257)) >> breath_in
1106:quantum/quantum.c **** 
1107:quantum/quantum.c **** }
1108:quantum/quantum.c **** 
1109:quantum/quantum.c **** #endif // breathing
1110:quantum/quantum.c **** 
1111:quantum/quantum.c **** #else // backlight
1112:quantum/quantum.c **** 
1113:quantum/quantum.c **** __attribute__ ((weak))
1114:quantum/quantum.c **** void backlight_init_ports(void)
1115:quantum/quantum.c **** {
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** }
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_set(uint8_t level)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c **** 
1123:quantum/quantum.c **** }
1124:quantum/quantum.c **** 
1125:quantum/quantum.c **** #endif // backlight
1126:quantum/quantum.c **** 
1127:quantum/quantum.c **** 
1128:quantum/quantum.c **** // Functions for spitting out values
1129:quantum/quantum.c **** //
1130:quantum/quantum.c **** 
1131:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1132:quantum/quantum.c ****     uint16_t word = (number >> 16);
1133:quantum/quantum.c ****     send_word(word);
1134:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1135:quantum/quantum.c **** }
1136:quantum/quantum.c **** 
1137:quantum/quantum.c **** void send_word(uint16_t number) {
1138:quantum/quantum.c ****     uint8_t byte = number >> 8;
1139:quantum/quantum.c ****     send_byte(byte);
1140:quantum/quantum.c ****     send_byte(number & 0xFF);
1141:quantum/quantum.c **** }
1142:quantum/quantum.c **** 
1143:quantum/quantum.c **** void send_byte(uint8_t number) {
1144:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1145:quantum/quantum.c ****     send_nibble(nibble);
1146:quantum/quantum.c ****     send_nibble(number & 0xF);
1147:quantum/quantum.c **** }
1148:quantum/quantum.c **** 
1149:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1774               		.loc 1 1149 0
 1775               		.cfi_startproc
 1776               	.LVL187:
 1777               		.loc 1 1149 0
 1778 0000 CF93      		push r28
 1779               	.LCFI38:
 1780               		.cfi_def_cfa_offset 3
 1781               		.cfi_offset 28, -2
 1782               	/* prologue: function */
 1783               	/* frame size = 0 */
 1784               	/* stack size = 1 */
 1785               	.L__stack_usage = 1
1150:quantum/quantum.c ****     switch (number) {
 1786               		.loc 1 1150 0
 1787 0002 8A30      		cpi r24,lo8(10)
 1788 0004 00F4      		brsh .L169
 1789 0006 8130      		cpi r24,lo8(1)
 1790 0008 00F0      		brlo .L173
1151:quantum/quantum.c ****         case 0:
1152:quantum/quantum.c ****             register_code(KC_0);
1153:quantum/quantum.c ****             unregister_code(KC_0);
1154:quantum/quantum.c ****             break;
1155:quantum/quantum.c ****         case 1 ... 9:
1156:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 1791               		.loc 1 1156 0
 1792 000a CDE1      		ldi r28,lo8(29)
 1793               	.L176:
1157:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1158:quantum/quantum.c ****             break;
1159:quantum/quantum.c ****         case 0xA ... 0xF:
1160:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1794               		.loc 1 1160 0
 1795 000c C80F      		add r28,r24
 1796 000e 8C2F      		mov r24,r28
 1797               	.LVL188:
 1798 0010 0E94 0000 		call register_code
 1799               	.LVL189:
1161:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1800               		.loc 1 1161 0
 1801 0014 8C2F      		mov r24,r28
 1802 0016 00C0      		rjmp .L175
 1803               	.LVL190:
 1804               	.L169:
1160:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1805               		.loc 1 1160 0
 1806 0018 CAEF      		ldi r28,lo8(-6)
1150:quantum/quantum.c ****         case 0:
 1807               		.loc 1 1150 0
 1808 001a 8031      		cpi r24,lo8(16)
 1809 001c 00F0      		brlo .L176
 1810               	/* epilogue start */
1162:quantum/quantum.c ****             break;
1163:quantum/quantum.c ****     }
1164:quantum/quantum.c **** }
 1811               		.loc 1 1164 0
 1812 001e CF91      		pop r28
 1813 0020 0895      		ret
 1814               	.L173:
1152:quantum/quantum.c ****             unregister_code(KC_0);
 1815               		.loc 1 1152 0
 1816 0022 87E2      		ldi r24,lo8(39)
 1817               	.LVL191:
 1818 0024 0E94 0000 		call register_code
 1819               	.LVL192:
1153:quantum/quantum.c ****             break;
 1820               		.loc 1 1153 0
 1821 0028 87E2      		ldi r24,lo8(39)
 1822               	.L175:
 1823               	/* epilogue start */
 1824               		.loc 1 1164 0
 1825 002a CF91      		pop r28
1161:quantum/quantum.c ****             break;
 1826               		.loc 1 1161 0
 1827 002c 0C94 0000 		jmp unregister_code
 1828               	.LVL193:
 1829               		.cfi_endproc
 1830               	.LFE137:
 1832               		.section	.text.send_byte,"ax",@progbits
 1833               	.global	send_byte
 1835               	send_byte:
 1836               	.LFB136:
1143:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1837               		.loc 1 1143 0
 1838               		.cfi_startproc
 1839               	.LVL194:
 1840 0000 CF93      		push r28
 1841               	.LCFI39:
 1842               		.cfi_def_cfa_offset 3
 1843               		.cfi_offset 28, -2
 1844               	/* prologue: function */
 1845               	/* frame size = 0 */
 1846               	/* stack size = 1 */
 1847               	.L__stack_usage = 1
 1848 0002 C82F      		mov r28,r24
 1849               	.LVL195:
1145:quantum/quantum.c ****     send_nibble(number & 0xF);
 1850               		.loc 1 1145 0
 1851 0004 8295      		swap r24
 1852               	.LVL196:
 1853 0006 8F70      		andi r24,lo8(15)
 1854 0008 0E94 0000 		call send_nibble
 1855               	.LVL197:
1146:quantum/quantum.c **** }
 1856               		.loc 1 1146 0
 1857 000c 8C2F      		mov r24,r28
 1858 000e 8F70      		andi r24,lo8(15)
 1859               	/* epilogue start */
1147:quantum/quantum.c **** 
 1860               		.loc 1 1147 0
 1861 0010 CF91      		pop r28
 1862               	.LVL198:
1146:quantum/quantum.c **** }
 1863               		.loc 1 1146 0
 1864 0012 0C94 0000 		jmp send_nibble
 1865               	.LVL199:
 1866               		.cfi_endproc
 1867               	.LFE136:
 1869               		.section	.text.send_word,"ax",@progbits
 1870               	.global	send_word
 1872               	send_word:
 1873               	.LFB135:
1137:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1874               		.loc 1 1137 0
 1875               		.cfi_startproc
 1876               	.LVL200:
 1877 0000 CF93      		push r28
 1878               	.LCFI40:
 1879               		.cfi_def_cfa_offset 3
 1880               		.cfi_offset 28, -2
 1881               	/* prologue: function */
 1882               	/* frame size = 0 */
 1883               	/* stack size = 1 */
 1884               	.L__stack_usage = 1
 1885 0002 C82F      		mov r28,r24
 1886               	.LVL201:
1139:quantum/quantum.c ****     send_byte(number & 0xFF);
 1887               		.loc 1 1139 0
 1888 0004 892F      		mov r24,r25
 1889               	.LVL202:
 1890 0006 0E94 0000 		call send_byte
 1891               	.LVL203:
1140:quantum/quantum.c **** }
 1892               		.loc 1 1140 0
 1893 000a 8C2F      		mov r24,r28
 1894               	/* epilogue start */
1141:quantum/quantum.c **** 
 1895               		.loc 1 1141 0
 1896 000c CF91      		pop r28
1140:quantum/quantum.c **** }
 1897               		.loc 1 1140 0
 1898 000e 0C94 0000 		jmp send_byte
 1899               	.LVL204:
 1900               		.cfi_endproc
 1901               	.LFE135:
 1903               		.section	.text.send_dword,"ax",@progbits
 1904               	.global	send_dword
 1906               	send_dword:
 1907               	.LFB134:
1131:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1908               		.loc 1 1131 0
 1909               		.cfi_startproc
 1910               	.LVL205:
 1911 0000 CF92      		push r12
 1912               	.LCFI41:
 1913               		.cfi_def_cfa_offset 3
 1914               		.cfi_offset 12, -2
 1915 0002 DF92      		push r13
 1916               	.LCFI42:
 1917               		.cfi_def_cfa_offset 4
 1918               		.cfi_offset 13, -3
 1919 0004 EF92      		push r14
 1920               	.LCFI43:
 1921               		.cfi_def_cfa_offset 5
 1922               		.cfi_offset 14, -4
 1923 0006 FF92      		push r15
 1924               	.LCFI44:
 1925               		.cfi_def_cfa_offset 6
 1926               		.cfi_offset 15, -5
 1927               	/* prologue: function */
 1928               	/* frame size = 0 */
 1929               	/* stack size = 4 */
 1930               	.L__stack_usage = 4
 1931 0008 6B01      		movw r12,r22
1133:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1932               		.loc 1 1133 0
 1933 000a 0E94 0000 		call send_word
 1934               	.LVL206:
1134:quantum/quantum.c **** }
 1935               		.loc 1 1134 0
 1936 000e C601      		movw r24,r12
 1937               	/* epilogue start */
1135:quantum/quantum.c **** 
 1938               		.loc 1 1135 0
 1939 0010 FF90      		pop r15
 1940 0012 EF90      		pop r14
 1941 0014 DF90      		pop r13
 1942 0016 CF90      		pop r12
1134:quantum/quantum.c **** }
 1943               		.loc 1 1134 0
 1944 0018 0C94 0000 		jmp send_word
 1945               	.LVL207:
 1946               		.cfi_endproc
 1947               	.LFE134:
 1949               		.section	.text.hex_to_keycode,"ax",@progbits
 1950               		.weak	hex_to_keycode
 1952               	hex_to_keycode:
 1953               	.LFB138:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** 
1167:quantum/quantum.c **** __attribute__((weak))
1168:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1169:quantum/quantum.c **** {
 1954               		.loc 1 1169 0
 1955               		.cfi_startproc
 1956               	.LVL208:
 1957               	/* prologue: function */
 1958               	/* frame size = 0 */
 1959               	/* stack size = 0 */
 1960               	.L__stack_usage = 0
1170:quantum/quantum.c ****   hex = hex & 0xF;
 1961               		.loc 1 1170 0
 1962 0000 282F      		mov r18,r24
 1963 0002 2F70      		andi r18,lo8(15)
 1964               	.LVL209:
1171:quantum/quantum.c ****   if (hex == 0x0) {
 1965               		.loc 1 1171 0
 1966 0004 01F0      		breq .L183
 1967 0006 822F      		mov r24,r18
 1968 0008 90E0      		ldi r25,0
1172:quantum/quantum.c ****     return KC_0;
1173:quantum/quantum.c ****   } else if (hex < 0xA) {
 1969               		.loc 1 1173 0
 1970 000a 2A30      		cpi r18,lo8(10)
 1971 000c 00F4      		brsh .L182
1174:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 1972               		.loc 1 1174 0
 1973 000e 4D96      		adiw r24,29
 1974 0010 0895      		ret
 1975               	.L182:
1175:quantum/quantum.c ****   } else {
1176:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 1976               		.loc 1 1176 0
 1977 0012 0697      		sbiw r24,6
 1978 0014 0895      		ret
 1979               	.L183:
1172:quantum/quantum.c ****   } else if (hex < 0xA) {
 1980               		.loc 1 1172 0
 1981 0016 87E2      		ldi r24,lo8(39)
 1982 0018 90E0      		ldi r25,0
 1983               	/* epilogue start */
1177:quantum/quantum.c ****   }
1178:quantum/quantum.c **** }
 1984               		.loc 1 1178 0
 1985 001a 0895      		ret
 1986               		.cfi_endproc
 1987               	.LFE138:
 1989               		.section	.text.api_send_unicode,"ax",@progbits
 1990               	.global	api_send_unicode
 1992               	api_send_unicode:
 1993               	.LFB139:
1179:quantum/quantum.c **** 
1180:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1994               		.loc 1 1180 0
 1995               		.cfi_startproc
 1996               	.LVL210:
 1997               	/* prologue: function */
 1998               	/* frame size = 0 */
 1999               	/* stack size = 0 */
 2000               	.L__stack_usage = 0
 2001               	/* epilogue start */
1181:quantum/quantum.c **** #ifdef API_ENABLE
1182:quantum/quantum.c ****     uint8_t chunk[4];
1183:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1184:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1185:quantum/quantum.c **** #endif
1186:quantum/quantum.c **** }
 2002               		.loc 1 1186 0
 2003 0000 0895      		ret
 2004               		.cfi_endproc
 2005               	.LFE139:
 2007               		.section	.text.led_set_user,"ax",@progbits
 2008               		.weak	led_set_user
 2010               	led_set_user:
 2011               	.LFB140:
1187:quantum/quantum.c **** 
1188:quantum/quantum.c **** __attribute__ ((weak))
1189:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2012               		.loc 1 1189 0
 2013               		.cfi_startproc
 2014               	.LVL211:
 2015               	/* prologue: function */
 2016               	/* frame size = 0 */
 2017               	/* stack size = 0 */
 2018               	.L__stack_usage = 0
 2019               	/* epilogue start */
1190:quantum/quantum.c **** 
1191:quantum/quantum.c **** }
 2020               		.loc 1 1191 0
 2021 0000 0895      		ret
 2022               		.cfi_endproc
 2023               	.LFE140:
 2025               		.set	led_set_user.localalias.1,led_set_user
 2026               		.section	.text.backlight_set,"ax",@progbits
 2027               		.weak	backlight_set
 2029               	backlight_set:
 2030               	.LFB153:
 2031               		.cfi_startproc
 2032               	/* prologue: function */
 2033               	/* frame size = 0 */
 2034               	/* stack size = 0 */
 2035               	.L__stack_usage = 0
 2036               	/* epilogue start */
 2037 0000 0895      		ret
 2038               		.cfi_endproc
 2039               	.LFE153:
 2041               		.section	.text.led_set_kb,"ax",@progbits
 2042               		.weak	led_set_kb
 2044               	led_set_kb:
 2045               	.LFB141:
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** __attribute__ ((weak))
1194:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2046               		.loc 1 1194 0
 2047               		.cfi_startproc
 2048               	.LVL212:
 2049               	/* prologue: function */
 2050               	/* frame size = 0 */
 2051               	/* stack size = 0 */
 2052               	.L__stack_usage = 0
1195:quantum/quantum.c ****     led_set_user(usb_led);
 2053               		.loc 1 1195 0
 2054 0000 0C94 0000 		jmp led_set_user
 2055               	.LVL213:
 2056               		.cfi_endproc
 2057               	.LFE141:
 2059               		.section	.text.led_init_ports,"ax",@progbits
 2060               		.weak	led_init_ports
 2062               	led_init_ports:
 2063               	.LFB142:
1196:quantum/quantum.c **** }
1197:quantum/quantum.c **** 
1198:quantum/quantum.c **** __attribute__ ((weak))
1199:quantum/quantum.c **** void led_init_ports(void)
1200:quantum/quantum.c **** {
 2064               		.loc 1 1200 0
 2065               		.cfi_startproc
 2066               	/* prologue: function */
 2067               	/* frame size = 0 */
 2068               	/* stack size = 0 */
 2069               	.L__stack_usage = 0
 2070               	/* epilogue start */
1201:quantum/quantum.c **** 
1202:quantum/quantum.c **** }
 2071               		.loc 1 1202 0
 2072 0000 0895      		ret
 2073               		.cfi_endproc
 2074               	.LFE142:
 2076               		.section	.text.led_set,"ax",@progbits
 2077               		.weak	led_set
 2079               	led_set:
 2080               	.LFB143:
1203:quantum/quantum.c **** 
1204:quantum/quantum.c **** __attribute__ ((weak))
1205:quantum/quantum.c **** void led_set(uint8_t usb_led)
1206:quantum/quantum.c **** {
 2081               		.loc 1 1206 0
 2082               		.cfi_startproc
 2083               	.LVL214:
 2084               	/* prologue: function */
 2085               	/* frame size = 0 */
 2086               	/* stack size = 0 */
 2087               	.L__stack_usage = 0
1207:quantum/quantum.c **** 
1208:quantum/quantum.c ****   // Example LED Code
1209:quantum/quantum.c ****   //
1210:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1211:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1212:quantum/quantum.c ****     // {
1213:quantum/quantum.c ****     //     // Output high.
1214:quantum/quantum.c ****     //     DDRE |= (1<<6);
1215:quantum/quantum.c ****     //     PORTE |= (1<<6);
1216:quantum/quantum.c ****     // }
1217:quantum/quantum.c ****     // else
1218:quantum/quantum.c ****     // {
1219:quantum/quantum.c ****     //     // Output low.
1220:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1221:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1222:quantum/quantum.c ****     // }
1223:quantum/quantum.c **** 
1224:quantum/quantum.c ****   led_set_kb(usb_led);
 2088               		.loc 1 1224 0
 2089 0000 0C94 0000 		jmp led_set_kb
 2090               	.LVL215:
 2091               		.cfi_endproc
 2092               	.LFE143:
 2094               		.section	.text.startup_user,"ax",@progbits
 2095               		.weak	startup_user
 2097               	startup_user:
 2098               	.LFB147:
 2099               		.cfi_startproc
 2100               	/* prologue: function */
 2101               	/* frame size = 0 */
 2102               	/* stack size = 0 */
 2103               	.L__stack_usage = 0
 2104               	/* epilogue start */
 2105 0000 0895      		ret
 2106               		.cfi_endproc
 2107               	.LFE147:
 2109               		.section	.text.shutdown_user,"ax",@progbits
 2110               		.weak	shutdown_user
 2112               	shutdown_user:
 2113               	.LFB149:
 2114               		.cfi_startproc
 2115               	/* prologue: function */
 2116               	/* frame size = 0 */
 2117               	/* stack size = 0 */
 2118               	.L__stack_usage = 0
 2119               	/* epilogue start */
 2120 0000 0895      		ret
 2121               		.cfi_endproc
 2122               	.LFE149:
 2124               		.weak	ascii_to_keycode_lut
 2125               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2128               	ascii_to_keycode_lut:
 2129 0000 00        		.byte	0
 2130 0001 00        		.byte	0
 2131 0002 00        		.byte	0
 2132 0003 00        		.byte	0
 2133 0004 00        		.byte	0
 2134 0005 00        		.byte	0
 2135 0006 00        		.byte	0
 2136 0007 00        		.byte	0
 2137 0008 2A        		.byte	42
 2138 0009 2B        		.byte	43
 2139 000a 28        		.byte	40
 2140 000b 00        		.byte	0
 2141 000c 00        		.byte	0
 2142 000d 00        		.byte	0
 2143 000e 00        		.byte	0
 2144 000f 00        		.byte	0
 2145 0010 00        		.byte	0
 2146 0011 00        		.byte	0
 2147 0012 00        		.byte	0
 2148 0013 00        		.byte	0
 2149 0014 00        		.byte	0
 2150 0015 00        		.byte	0
 2151 0016 00        		.byte	0
 2152 0017 00        		.byte	0
 2153 0018 00        		.byte	0
 2154 0019 00        		.byte	0
 2155 001a 00        		.byte	0
 2156 001b 29        		.byte	41
 2157 001c 00        		.byte	0
 2158 001d 00        		.byte	0
 2159 001e 00        		.byte	0
 2160 001f 00        		.byte	0
 2161 0020 2C        		.byte	44
 2162 0021 1E        		.byte	30
 2163 0022 34        		.byte	52
 2164 0023 20        		.byte	32
 2165 0024 21        		.byte	33
 2166 0025 22        		.byte	34
 2167 0026 24        		.byte	36
 2168 0027 34        		.byte	52
 2169 0028 26        		.byte	38
 2170 0029 27        		.byte	39
 2171 002a 25        		.byte	37
 2172 002b 2E        		.byte	46
 2173 002c 36        		.byte	54
 2174 002d 2D        		.byte	45
 2175 002e 37        		.byte	55
 2176 002f 38        		.byte	56
 2177 0030 27        		.byte	39
 2178 0031 1E        		.byte	30
 2179 0032 1F        		.byte	31
 2180 0033 20        		.byte	32
 2181 0034 21        		.byte	33
 2182 0035 22        		.byte	34
 2183 0036 23        		.byte	35
 2184 0037 24        		.byte	36
 2185 0038 25        		.byte	37
 2186 0039 26        		.byte	38
 2187 003a 33        		.byte	51
 2188 003b 33        		.byte	51
 2189 003c 36        		.byte	54
 2190 003d 2E        		.byte	46
 2191 003e 37        		.byte	55
 2192 003f 38        		.byte	56
 2193 0040 1F        		.byte	31
 2194 0041 04        		.byte	4
 2195 0042 05        		.byte	5
 2196 0043 06        		.byte	6
 2197 0044 07        		.byte	7
 2198 0045 08        		.byte	8
 2199 0046 09        		.byte	9
 2200 0047 0A        		.byte	10
 2201 0048 0B        		.byte	11
 2202 0049 0C        		.byte	12
 2203 004a 0D        		.byte	13
 2204 004b 0E        		.byte	14
 2205 004c 0F        		.byte	15
 2206 004d 10        		.byte	16
 2207 004e 11        		.byte	17
 2208 004f 12        		.byte	18
 2209 0050 13        		.byte	19
 2210 0051 14        		.byte	20
 2211 0052 15        		.byte	21
 2212 0053 16        		.byte	22
 2213 0054 17        		.byte	23
 2214 0055 18        		.byte	24
 2215 0056 19        		.byte	25
 2216 0057 1A        		.byte	26
 2217 0058 1B        		.byte	27
 2218 0059 1C        		.byte	28
 2219 005a 1D        		.byte	29
 2220 005b 2F        		.byte	47
 2221 005c 31        		.byte	49
 2222 005d 30        		.byte	48
 2223 005e 23        		.byte	35
 2224 005f 2D        		.byte	45
 2225 0060 35        		.byte	53
 2226 0061 04        		.byte	4
 2227 0062 05        		.byte	5
 2228 0063 06        		.byte	6
 2229 0064 07        		.byte	7
 2230 0065 08        		.byte	8
 2231 0066 09        		.byte	9
 2232 0067 0A        		.byte	10
 2233 0068 0B        		.byte	11
 2234 0069 0C        		.byte	12
 2235 006a 0D        		.byte	13
 2236 006b 0E        		.byte	14
 2237 006c 0F        		.byte	15
 2238 006d 10        		.byte	16
 2239 006e 11        		.byte	17
 2240 006f 12        		.byte	18
 2241 0070 13        		.byte	19
 2242 0071 14        		.byte	20
 2243 0072 15        		.byte	21
 2244 0073 16        		.byte	22
 2245 0074 17        		.byte	23
 2246 0075 18        		.byte	24
 2247 0076 19        		.byte	25
 2248 0077 1A        		.byte	26
 2249 0078 1B        		.byte	27
 2250 0079 1C        		.byte	28
 2251 007a 1D        		.byte	29
 2252 007b 2F        		.byte	47
 2253 007c 31        		.byte	49
 2254 007d 30        		.byte	48
 2255 007e 35        		.byte	53
 2256 007f 4C        		.byte	76
 2257               		.weak	ascii_to_shift_lut
 2258               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2261               	ascii_to_shift_lut:
 2262 0000 00        		.byte	0
 2263 0001 00        		.byte	0
 2264 0002 00        		.byte	0
 2265 0003 00        		.byte	0
 2266 0004 00        		.byte	0
 2267 0005 00        		.byte	0
 2268 0006 00        		.byte	0
 2269 0007 00        		.byte	0
 2270 0008 00        		.byte	0
 2271 0009 00        		.byte	0
 2272 000a 00        		.byte	0
 2273 000b 00        		.byte	0
 2274 000c 00        		.byte	0
 2275 000d 00        		.byte	0
 2276 000e 00        		.byte	0
 2277 000f 00        		.byte	0
 2278 0010 00        		.byte	0
 2279 0011 00        		.byte	0
 2280 0012 00        		.byte	0
 2281 0013 00        		.byte	0
 2282 0014 00        		.byte	0
 2283 0015 00        		.byte	0
 2284 0016 00        		.byte	0
 2285 0017 00        		.byte	0
 2286 0018 00        		.byte	0
 2287 0019 00        		.byte	0
 2288 001a 00        		.byte	0
 2289 001b 00        		.byte	0
 2290 001c 00        		.byte	0
 2291 001d 00        		.byte	0
 2292 001e 00        		.byte	0
 2293 001f 00        		.byte	0
 2294 0020 00        		.byte	0
 2295 0021 01        		.byte	1
 2296 0022 01        		.byte	1
 2297 0023 01        		.byte	1
 2298 0024 01        		.byte	1
 2299 0025 01        		.byte	1
 2300 0026 01        		.byte	1
 2301 0027 00        		.byte	0
 2302 0028 01        		.byte	1
 2303 0029 01        		.byte	1
 2304 002a 01        		.byte	1
 2305 002b 01        		.byte	1
 2306 002c 00        		.byte	0
 2307 002d 00        		.byte	0
 2308 002e 00        		.byte	0
 2309 002f 00        		.byte	0
 2310 0030 00        		.byte	0
 2311 0031 00        		.byte	0
 2312 0032 00        		.byte	0
 2313 0033 00        		.byte	0
 2314 0034 00        		.byte	0
 2315 0035 00        		.byte	0
 2316 0036 00        		.byte	0
 2317 0037 00        		.byte	0
 2318 0038 00        		.byte	0
 2319 0039 00        		.byte	0
 2320 003a 01        		.byte	1
 2321 003b 00        		.byte	0
 2322 003c 01        		.byte	1
 2323 003d 00        		.byte	0
 2324 003e 01        		.byte	1
 2325 003f 01        		.byte	1
 2326 0040 01        		.byte	1
 2327 0041 01        		.byte	1
 2328 0042 01        		.byte	1
 2329 0043 01        		.byte	1
 2330 0044 01        		.byte	1
 2331 0045 01        		.byte	1
 2332 0046 01        		.byte	1
 2333 0047 01        		.byte	1
 2334 0048 01        		.byte	1
 2335 0049 01        		.byte	1
 2336 004a 01        		.byte	1
 2337 004b 01        		.byte	1
 2338 004c 01        		.byte	1
 2339 004d 01        		.byte	1
 2340 004e 01        		.byte	1
 2341 004f 01        		.byte	1
 2342 0050 01        		.byte	1
 2343 0051 01        		.byte	1
 2344 0052 01        		.byte	1
 2345 0053 01        		.byte	1
 2346 0054 01        		.byte	1
 2347 0055 01        		.byte	1
 2348 0056 01        		.byte	1
 2349 0057 01        		.byte	1
 2350 0058 01        		.byte	1
 2351 0059 01        		.byte	1
 2352 005a 01        		.byte	1
 2353 005b 00        		.byte	0
 2354 005c 00        		.byte	0
 2355 005d 00        		.byte	0
 2356 005e 01        		.byte	1
 2357 005f 01        		.byte	1
 2358 0060 00        		.byte	0
 2359 0061 00        		.byte	0
 2360 0062 00        		.byte	0
 2361 0063 00        		.byte	0
 2362 0064 00        		.byte	0
 2363 0065 00        		.byte	0
 2364 0066 00        		.byte	0
 2365 0067 00        		.byte	0
 2366 0068 00        		.byte	0
 2367 0069 00        		.byte	0
 2368 006a 00        		.byte	0
 2369 006b 00        		.byte	0
 2370 006c 00        		.byte	0
 2371 006d 00        		.byte	0
 2372 006e 00        		.byte	0
 2373 006f 00        		.byte	0
 2374 0070 00        		.byte	0
 2375 0071 00        		.byte	0
 2376 0072 00        		.byte	0
 2377 0073 00        		.byte	0
 2378 0074 00        		.byte	0
 2379 0075 00        		.byte	0
 2380 0076 00        		.byte	0
 2381 0077 00        		.byte	0
 2382 0078 00        		.byte	0
 2383 0079 00        		.byte	0
 2384 007a 00        		.byte	0
 2385 007b 01        		.byte	1
 2386 007c 01        		.byte	1
 2387 007d 01        		.byte	1
 2388 007e 01        		.byte	1
 2389 007f 00        		.byte	0
 2390               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2393               	grave_esc_was_shifted:
 2394 0000 00        		.zero	1
 2395               		.section	.bss.scs_timer,"aw",@nobits
 2398               	scs_timer:
 2399 0000 0000 0000 		.zero	4
 2400               		.section	.bss.shift_interrupted,"aw",@nobits
 2403               	shift_interrupted:
 2404 0000 0000      		.zero	2
 2405               		.text
 2406               	.Letext0:
 2407               		.file 3 "/usr/avr/include/stdint.h"
 2408               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 2409               		.file 5 "./tmk_core/common/keyboard.h"
 2410               		.file 6 "./tmk_core/common/action.h"
 2411               		.file 7 "./lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2412               		.file 8 "./lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2413               		.file 9 "./lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2414               		.file 10 "./lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2415               		.file 11 "/usr/avr/include/stdio.h"
 2416               		.file 12 "./tmk_core/common/report.h"
 2417               		.file 13 "./tmk_core/common/host.h"
 2418               		.file 14 "./tmk_core/common/debug.h"
 2419               		.file 15 "quantum/keycode_config.h"
 2420               		.file 16 "./tmk_core/common/keycode.h"
 2421               		.file 17 "quantum/quantum_keycodes.h"
 2422               		.file 18 "quantum/keymap.h"
 2423               		.file 19 "./tmk_core/common/action_layer.h"
 2424               		.file 20 "./tmk_core/common/timer.h"
 2425               		.file 21 "./tmk_core/common/action_util.h"
 2426               		.file 22 "/usr/avr/include/stdlib.h"
 2427               		.file 23 "quantum/quantum.h"
 2428               		.file 24 "./tmk_core/protocol/lufa/outputselect.h"
 2429               		.file 25 "./tmk_core/common/backlight.h"
 2430               		.file 26 "./tmk_core/common/eeconfig.h"
 2431               		.file 27 "./quantum/process_keycode/process_steno.h"
 2432               		.file 28 "./quantum/process_keycode/process_leader.h"
 2433               		.file 29 "./tmk_core/common/bootloader.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccZV5ng8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccZV5ng8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccZV5ng8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccZV5ng8.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccZV5ng8.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccZV5ng8.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccZV5ng8.s:132    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccZV5ng8.s:162    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccZV5ng8.s:175    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccZV5ng8.s:205    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccZV5ng8.s:219    .text.register_code16:0000000000000000 register_code16
     /tmp/ccZV5ng8.s:275    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccZV5ng8.s:329    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccZV5ng8.s:349    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccZV5ng8.s:369    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccZV5ng8.s:387    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccZV5ng8.s:423    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccZV5ng8.s:2403   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccZV5ng8.s:2398   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccZV5ng8.s:2393   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccZV5ng8.s:967    .text.send_char:0000000000000000 send_char
     /tmp/ccZV5ng8.s:2128   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccZV5ng8.s:2261   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccZV5ng8.s:1051   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccZV5ng8.s:1196   .text.send_string:0000000000000000 send_string
     /tmp/ccZV5ng8.s:1215   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccZV5ng8.s:1393   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccZV5ng8.s:1412   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccZV5ng8.s:1460   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccZV5ng8.s:1597   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccZV5ng8.s:1723   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccZV5ng8.s:1740   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccZV5ng8.s:1757   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccZV5ng8.s:1772   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccZV5ng8.s:1835   .text.send_byte:0000000000000000 send_byte
     /tmp/ccZV5ng8.s:1872   .text.send_word:0000000000000000 send_word
     /tmp/ccZV5ng8.s:1906   .text.send_dword:0000000000000000 send_dword
     /tmp/ccZV5ng8.s:1952   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccZV5ng8.s:1992   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccZV5ng8.s:2010   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccZV5ng8.s:2010   .text.led_set_user:0000000000000000 led_set_user.localalias.1
     /tmp/ccZV5ng8.s:2029   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccZV5ng8.s:2044   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccZV5ng8.s:2062   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccZV5ng8.s:2079   .text.led_set:0000000000000000 led_set
     /tmp/ccZV5ng8.s:2097   .text.startup_user:0000000000000000 startup_user
     /tmp/ccZV5ng8.s:2112   .text.shutdown_user:0000000000000000 shutdown_user

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
process_steno
process_leader
read_source_layers_cache
timer_read
register_mods
debug_config
set_output
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_elapsed
unregister_mods
get_mods
add_key
del_key
eeconfig_update_default_layer
default_layer_set
layer_state
layer_on
layer_off
matrix_init_kb
matrix_scan_kb
__do_clear_bss
